---
title: Using AI With R
author: Luke Li and David Kane
tutorial:
  id: r4ds-3
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Tutorial for R for Data Science Integrated with AI (test)'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)

library(babynames)
library(nycflights13)

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 600, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

<!-- DK: Make this look like: https://ppbds.github.io/tutorial.helpers/articles/ai.html -->

<!-- That means, there are Introduction; Summary and, in between, there are three Topics. -->

<!-- DK: `SG:` is only for things we need to discuss, not reminders. -->

<!-- DK: Give them instructions to download the duckdb. -->


### Exercise 3

Place your cursor in the QMD file on the `library(tidyverse)` line. Use `Cmd/Ctrl + Enter` to execute that line.

Note that this causes `library(tidyverse)` to be copied down to the Console and then executed. 

CP/CR.

```{r introduction-3}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 3)
```

###



## Flights
###


This section covers [Chapter 13: Numbers](https://r4ds.hadley.nz/numbers.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. We will be utilizing two core packages of Tidyverse, [**readr**](https://readr.tidyverse.org/) and [**dplyr**](https://dplyr.tidyverse.org/). Key commands of this section will include [`parse_double()`](https://readr.tidyverse.org/reference/parse_atomic.html) for parsing numbers directly from strings, [`parse_number()`](https://readr.tidyverse.org/reference/parse_number.html) for removing useless characters and parsing numbers from strings, [`count()`](https://dplyr.tidyverse.org/reference/count.html) which counts the unique values of one or more variables, [`pmin()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Extremes.html) which take one or more vectors in and returns the minima or maxima of these vectors, 
[`round()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Round.html) which rounds values in its first argument to the specified number of decimal places, and [`min_rank()`](https://dplyr.tidyverse.org/reference/row_number.html) which gives every tie the same value and ranks an inputted vector.


### Exercise 1

In the same setup chunk with **tidyverse**, load `nycflights13` with the `library()` function. 

Place your cursor on that line and run `Cmd/Ctrl + Enter` to load the package in the Console.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r numbers-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

This dataset from the contains information about all flights that departed from NYC (e.g. EWR, JFK and LGA) to destinations in the United States, Puerto Rico, and the American Virgin Islands) in 2013.

### Exercise 2

Type `flights` in the Console to view the dataset. Copy and paste the resulting tibble.

```{r numbers-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 8)
```

###

Typing out `flights` is the same as typing out `print(flights)`. You might be wondering what tibble is, A tibble is a new form of a data frame in R that is part of the tidyverse library, and tibbles print the data in a more efficient format than a data frame, showing the values of the columns, their datatype, and the size of the dataset.

### Exercise 3

Now, ask your favorite  AI to generate R code that creates a new column from `flights` that just contains the numbers from the `tailnum` column. Then, only show that new column. Copy the code into the Console and hit `Enter` to run it.

CP/CR.

```{r numbers-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 4)
```

###

Our code:

```{r, echo=TRUE}
flights |>
  mutate(tailnum_num = parse_number(tailnum)) |> 
  select(tailnum_num)
```

Knowledge drop on parse_number(), parse_integer(), and parse_double().

### Exercise 4

Now, ask your favorite AI to use `select()` on `flights` to obtain only the columns `dep_time`, `sched_dep_time`, and `dep_delay`.
Make sure to provide a tibble of **flights** for the AI to use.

Assign the result of this pipe to `flights_clean`, and then add your code to a new chunk in the QMD.
Place your cursor on that line and run `Cmd/Ctrl + Enter` to load `flights_clean` in the Console.
Then, type `flights_clean` in the Console and hit `Enter`.

CP/CR the resulting tibble.

```{r numbers-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

###

Our code:

```{r, echo=TRUE}
flights_clean <- flights |>
  select(dep_time:dep_delay)
flights_clean
```


### Exercise 5

Next, prompt the AI to generate R code that takes `flights_clean` and breaks scheduled and actual departure times into hours and minutes using %/% and %%. If you have not done so before, provide a tibble of **flights_clean** for the AI to use. If necessary, change the code so that the result of the pipe is not assigned to a variable. Add the code to your QMD in a new chunk. Save the file. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r numbers-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 4)
```


###

Our code:

```{r, echo=TRUE}
flights_clean |>
  mutate(
    sched_hour = sched_dep_time %/% 100,
    sched_minute = sched_dep_time %% 100,
    dep_hour = dep_time %/% 100,
    dep_minute = dep_time %% 100)
```


### Exercise 6

Next, prompt the AI to generate R code that continues the pipe and adds a new column `true_dep_delay`, treating early departures (negative values) as 0 using `mutate()` and `pmax()`. If necessary, change the code so that the result of the pipe is not assigned to a variable. Add the code to your QMD in the same chunk. Save the file. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r numbers-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 6)
```


###

Our code:

```{r, echo=TRUE}
flights_clean |>
  mutate(
    sched_hour = sched_dep_time %/% 100,
    sched_minute = sched_dep_time %% 100,
    dep_hour = dep_time %/% 100,
    dep_minute = dep_time %% 100) |>
      mutate(true_dep_delay = pmax(dep_delay, 0))
```

### Exercise 7

Next, prompt the AI to generate R code that finishes the pipe and collapses the dataset, grouping by hour pairs and summing delay using `count(..., wt=...)`. Essentially, we want to sum the total number of minutes of positive departure delay for each combination of scheduled hour and actual departure hour.
If necessary, change the code so that the result of the pipe is not assigned to a variable. Add the code to your QMD in the same chunk. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r numbers-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 7)
```


###

Our code:

```{r, echo=TRUE}
flights_clean |>
  mutate(
    sched_hour = sched_dep_time %/% 100,
    sched_minute = sched_dep_time %% 100,
    dep_hour = dep_time %/% 100,
    dep_minute = dep_time %% 100) |>
      mutate(true_dep_delay = pmax(dep_delay, 0))|>
        count(sched_hour, dep_hour, wt = true_dep_delay, name = "total_delay")
```

### Exercise 8

Now that we have filtered our dataset through a pipe, we need to be on track with the same, correct, code. Replace your code with our code in your QMD.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r numbers-8}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 6)
```


### Exercise 9

Within the recent code chunk, add the
option: `#| cache: true`. Assign the result of our pipe to 
`x`. 

`Cmd/Ctrl + Shift + K`. By including `#| cache: true` 
you cause Quarto to cache the results of the chunk. 
The next time you render your QMD, as long as you have not changed 
the code, Quarto will just load up the saved fitted object.

Place your cursor on the line where the pipe is assigned to `x`,
run `Cmd/Ctrl + Enter`. Now, the workspace also includes a copy
of `x`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r numbers-9}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 6)
```


###

Our code:

```{r, echo=TRUE}
x <- flights_clean |>
  mutate(
    sched_hour = sched_dep_time %/% 100,
    sched_minute = sched_dep_time %% 100,
    dep_hour = dep_time %/% 100,
    dep_minute = dep_time %% 100) |>
      mutate(true_dep_delay = pmax(dep_delay, 0)) |>
        count(sched_hour, dep_hour, wt = true_dep_delay, name = "total_delay")
```


###

<!-- XX: Insert a knowledge drop related to this project. -->
### Exercise 10

Within the Console, type `x`, which we previously assigned to a pipe
and ran in the Console. Hit `Enter`.

CP/CR.

```{r ai-usage-10}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 8)
```

###

Our code:

```{r, echo=TRUE}
x
...
```

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 11

Go to the AI and ask it to generate R code that plots a clean and insightful heatmap that shows where delays tend to cluster by scheduled vs. actual departure hour. Mention you want to use the data from `x` and copy and paste the `x` you ran in the Console with the resulting tibble. You only need the top 3 lines, mainly to include column names.

Within `labs()` edit or add a proper title, subtitle, and caption. If axis labels are appropriate, add them, but if unnecessary, don't bother. Don't assign the code for the plot to any variable. Add this code to a new code cell. Run `Cmd/Ctrl + Shift + K`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r numbers-11}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 12)
```


###

Our code:

```{r echo=FALSE}
x <- flights_clean |>
  mutate(
    sched_hour = sched_dep_time %/% 100,
    sched_minute = sched_dep_time %% 100,
    dep_hour = dep_time %/% 100,
    dep_minute = dep_time %% 100) |>
      mutate(true_dep_delay = pmax(dep_delay, 0)) |>
        count(sched_hour, dep_hour, wt = true_dep_delay, name = "total_delay")
```

```{r, echo=TRUE}
ggplot(x, aes(x = sched_hour, y = dep_hour, fill = total_delay)) +
  geom_tile(color = "white") +
  scale_fill_viridis_c(option = "plasma", name = "Total Delay (min)") +
  labs(
    title = "Total Departure Delay by Scheduled Hour and Actual Hour",
    subtitle = "The most total delay time occurs around 5 PM with a 1 hour delay",
    x = "Scheduled Departure Hour",
    y = "Actual Departure Hour",
    caption = "Source: nycflights13::flights"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid = element_blank(),
    plot.title = element_text(face = "bold", size = 18),
    axis.text = element_text(face = "bold")
  )
```

### Exercise 12

Now, using AI, ask it to generate code that rounds the `total_delay` column to the hundreds place using `round()`. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into a new code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r numbers-11}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```


###

Our code:

```{r, echo=TRUE}
x |>
  mutate(total_delay = round(total_delay, -2))
```

### Exercise 13

Now, using AI, ask it to generate code that applies `min_rank()` to the `total_delay` column in `x` to see the ranks of the highest total delay times per combination of scheduled departure hour and actual departure hour. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r numbers-12}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```


###

Our code:

```{r, echo=TRUE}
x |>
  mutate(rank_total_delay = min_rank(desc(total_delay)))
```

### Exercise 14

Now, using AI, ask it to generate code that uses summarize() in your `x` dataset to calculate the mean, median, and 95th percentile (quantile) of `true_dep_delay`. In this case, copy and paste the pipe that is assigned to `x`, change it to `y`, and then remove the `count()`. Then, run the AI generated code on `y`. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into same the code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r numbers-13}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```


###

Our code:

```{r echo=TRUE}
y <- flights_clean |>
  mutate(
    sched_hour = sched_dep_time %/% 100,
    sched_minute = sched_dep_time %% 100,
    dep_hour = dep_time %/% 100,
    dep_minute = dep_time %% 100) |>
      mutate(true_dep_delay = pmax(dep_delay, 0))
```

```{r, echo=TRUE}
y |>
  summarize(
    mean_delay   = mean(true_dep_delay, na.rm = TRUE),
    median_delay = median(true_dep_delay, na.rm = TRUE),
    q95_delay    = quantile(true_dep_delay, 0.95, na.rm = TRUE)
  )
```

### Exercise 15

Now that we have all these functions in the same code cell, we can see all of the functions we have learned, and we can run any of them at will with `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r numbers-14}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 15)
``` 

###

Commit/push everything.



## Baby names
### 

This section covers [Chapter 14: Strings](https://r4ds.hadley.nz/strings.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. 
You will learn about some of the power of the [**stringr**](https://stringr.tidyverse.org/) package: how to create, combine, and extract strings, and about some of the challenges you might face with non-English strings. Some important functions which we will learn include:
[`str_c()`](https://stringr.tidyverse.org/reference/str_c.html),
[`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.html),
[`str_flatten()`](https://stringr.tidyverse.org/reference/str_flatten.html),
[`separate_longer_delim()`](https://tidyr.tidyverse.org/reference/separate_longer_delim.html), and more.

In this section we are going to focus on generating code to create a graph based on a dataset called `babynames`. The `babynames` is a dataset which contained names used for American babies from 1880 to 2017. If you want to explore related data, checkout [popular baby names](https://www.ssa.gov/oact/babynames/limits.html). We will be using AI to generate the code for us and then we will break down the functions within the code and how they work.

### Exercise 1

We begin by downloading a DuckDB version of the babynames dataset directly from GitHub using download.file(). This stores the database file (babynames.duckdb) in our working directory so we can use it in this tutorial.

Go to https://github.com/PPBDS/ai.tutorials and navigate to inst → extdata → babynames.duckdb.
Click on babynames.duckdb, right click the "Raw" button and choose Copy Link.

Now, ask AI how to use the `download.file()` function to save the `babynames.duckdb` file in your current working directory. Paste this code into your console.

CP/CR.

```{r strings-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

Use our code:

```{r, echo=TRUE, eval = FALSE}
download.file(
  "https://github.com/PPBDS/ai.tutorials/raw/refs/heads/main/inst/extdata/babynames.duckdb",
  destfile = "babynames.duckdb"
)
```

###

### Exercise 2
Next, ask AI how to connect and write the database as a table so it is accessible to use with the rest of the code in the document. Add the code to your QMD in a new chunk. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```
```{r strings-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 8)
```

Our code:
```{r, echo=TRUE}
con <- DBI::dbConnect(
    duckdb::duckdb(),
    dbdir = "babynames.duckdb"
  )

DBI::dbWriteTable(con, "babynames", babynames::babynames, overwrite = TRUE)
```

This creates a connection to the database and assigns it to the variable con, short for connection. This connection acts like a bridge between R and the DuckDB file. **DBI** is a low-level interface that connects to databases and executes SQL; **dbplyr** is a high-level interface that translates your **dplyr** code to SQL queries then executes them with **DBI**.


### Exercise 3

Now, ask AI how you can view the babynames.duckdb dataset using dbReadTable. Add this code to the QMD. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.
Copy and paste the resulting tibble.

```{r strings-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 8)
```

Our code:
```{r, echo=TRUE}
con |> 
    dbReadTable("babynames") |> 
    as_tibble()
```


Knowledge drop
###
### Exercise 4

Using your favorite AI, prompt it to generate R code that takes `babynames` and filters the dataset to show all names that have a first name starting with A after the year 2000, using SQL. Make sure to provide some lines of **babynames** for the AI to use. If necessary, change the code so that the result of the pipe is not assigned to a variable. Add the code to your QMD in a new chunk. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r strings-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 4)
```


###

Our code:

```{r, echo=TRUE}
sql <- "
  SELECT name, year, sex, n, prop
  FROM babynames
  WHERE name LIKE 'A%' AND year > 2000
"
```


A query is made up of **clauses**. There are five important clauses: `SELECT`, `FROM`, `WHERE`, `ORDER BY`, and `GROUP BY`. Every query must have the `SELECT` and `FROM` clauses and the simplest query is `SELECT * FROM table`, which selects all columns from the specified table. `WHERE` and `ORDER BY` control which rows are included and how they are ordered, and `GROUP BY` converts the query to a summary, causing aggregation to happen.

### Exercise 5

You just used SQL to filter the babynames database directly. Although, instead of writing raw SQL yourself, we can do the exact same task using dbplyr. dbplyr is a dplyr backend, which means that you keep writing dplyr code but the backend executes it differently. In this, dbplyr translates to SQL; other backends include dbplyr which translates to data.table, and multidplyr which executes your code on multiple cores.

Paste this code into a new chunk in your QMD:
```         
babynames_db <- tbl(con, "babynames")
```
To use dbplyr, you must first use tbl() to create an object that represents a database table. 
Ask AI how to use dbplyr to filter the data to show all names start with A after the year 2000. Paste this code into the same code chunk and place your cursor on a line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
``` 
Our code:
```{r, echo=TRUE}
babynames_db <- tbl(con, "babynames")
babynames_db |>
  filter(str_starts(name, "A"), year > 2000, n >= 10) 
```

<!--  Strings knowdlege drop-->


```{r strings-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 4)
```

### Exercise 6
Next, prompt AI to give you code that creates a new column of names classified as "Short" or "Long". Anything less than or equal to 5 can be classifed as short. Add this code as a continuation of your pipe to the same chunk in your QMD. Since the `babynames` is a data set which contains names used for babies from 1880 to 2017 in America, we are using the average length of an American name (5.44) truncated. 
In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
``` 
```{r strings-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 8)
```

<!--  logical vectors knowledge drop -->

Our code:
```{r, echo=TRUE}
babynames_db |>
  filter(str_starts(name, "A"), year > 2000, n >= 10) |>
  mutate(length_class = if_else(str_length(name) <= 5, "Short", "Long"))
```


###


### Exercise 7

Next, prompt AI to continue the pipe to summarize the data by grouping by year and length_class, calculating the total number of babies in each group by summing n. Add the code to your QMD in the same chunk. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r strings-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 7)
```

<!--  knowledge drop-->

###

Our code:

```{r, echo=TRUE}
babynames_db |>
  filter(str_starts(name, "A"), year > 2000, n >= 10) |>
  mutate(length_class = if_else(str_length(name) <= 5, "Short", "Long")) |>
  summarize(total = sum(n), .by = c(year, length_class)) |>
```

###

### Exercise 8

Now, prompt the AI to arrange the summarized results in ascending order by year, and collect the results from the database into a local R tibble for further use, such as plotting. Add the code to your QMD in the same chunk. Place your cursor on the first line of the code and run `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r strings-8}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 7)
```


###

Our code:

```{r, echo=TRUE}
babynames_db |>
  filter(str_starts(name, "A"), year > 2000, n >= 10) |>
  mutate(length_class = if_else(str_length(name) <= 5, "Short", "Long")) |>
  summarize(total = sum(n), .by = c(year, length_class)) |>
  arrange(year) |>
  collect()
```

<!--  knowledge drop, maybe about the sql equivalent-->

### Exercise 9

Now that we have filtered our dataset through a pipe, we need to be on track with the same, correct, code. Replace your code with our code in your QMD.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r strings-9}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 6)
```

###

<!--  knowledge drop-->


### Exercise 10

Within the recent code chunk, add the option: `#| cache: true`. Assign the result of our pipe to  `x`. 

`Cmd/Ctrl + Shift + K`. By including `#| cache: true` you cause Quarto to cache the results of the chunk. The next time you render your QMD, as long as you have not changed the code, Quarto will just load up the saved fitted object.

Place your cursor on the line where the pipe is assigned to x, run `Cmd/Ctrl + Enter`. Now, the workspace also includes a copy of `x`.

CP/CR.

```{r strings-10}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 8)
```

###

Our code:

```{r, echo=TRUE}
x <- babynames_db |>
  filter(str_starts(name, "A"), year > 2000, n >= 10) |>
  mutate(length_class = if_else(str_length(name) <= 5, "Short", "Long")) |>
  summarize(total = sum(n), .by = c(year, length_class)) |>
  arrange(year) |>
  collect()
```

<!--  knowledge drop-->

### Exercise 11

Within the Console, type `x`, which we previously assigned to a pipe
and ran in the Console. Hit `Enter`.

CP/CR.

```{r strings-11}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 8)
```

###

Our code:

```{r, echo=TRUE}
x
```

<!--  knowledge drop-->


### Exercise 12

<!-- https://pkgs.rstudio.com/learnr/articles/exercises.html -->

Go to the AI and ask it to generate R code that plots a basic line graph showing the proportion of "Short" vs. "Long" names starting with A over the years (after 2000). Mention you want to use the data from `x` and copy and paste the `x` you ran in the Console with the resulting dataframe. You only need the top 3 lines, mainly to include column names.

Within `labs()` edit or add a proper title, subtitle, and caption. If axis labels are appropriate, add them, but if unnecessary, don't bother. Don't assign the code to any variable. Add this code to a new code cell. Run `Cmd/Ctrl + Shift + K`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r strings-12}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 12)
```

<!--  knowledge drop-->


###

Our code:

```{r echo=FALSE}
x <- babynames_db |>
  filter(str_starts(name, "A"), year > 2000, n >= 10) |>
  mutate(length_class = if_else(str_length(name) <= 5, "Short", "Long")) |>
  summarize(total = sum(n), .by = c(year, length_class)) |>
  arrange(year) |>
  collect()

```

```{r, echo=TRUE}
ggplot(a_names, aes(x = year, y = total, color = length_class)) +
  geom_line(size = 1.2) +
  labs(
    title = "Trends in Short vs Long A-Names Since 2000",
	subtitle = "Long baby names starting with A are becoming less popular"
    x = "Year", y = "Total Babies",
    color = "Name Length",
	caption = "Source: Babynames"
  ) +
  theme_minimal()
```

###


### Exercise 13

Using the same AI, ask it to generate code for finding the top five longest names beginning with 'A' in 2009. 

Here is the prompt we used: using R, create code that finds the top five longest names beginning with 'A' in 2009. First use `filter()` and `slice_head()` to get the top names of the 'A' name column ordered by highest proportion, then use `pull()` to create a vector of the column, and finally use `str_flatten()` to create a string. Use `str_c()` to print out a coherent sentence at the end. 

Make sure you also provide the modified tibble `x` from earlier.

In a new code chunk after the graph, copy and paste our generated code into your QMD. Render it with `Cmd/Ctrl + K`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r strings-13}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 12)
```


###

Our code:

```{r, echo=TRUE}
top_a_1950 <- babynames |>
  filter(year == 2009, str_starts(name, "A")) |>
  mutate(name_length = str_length(name)) |>
  arrange(desc(name_length)) |>
  slice_head(n = 5)

insight_text <- top_a_1950 |>
  pull(name) |> # returns a vector from the column
  str_flatten(collapse = ", ", last = " and ") # combines vector into a string

insight <- str_c(
  "In 2009, the longest 'A' names were ", insight_text, 
  "."
)
insight
```

`str_c()` and `str_glue()` are suitable for use with `mutate()` since their output matches the length of their inputs. However, if you need a function that works well with `summarize()` and always returns a single string, `str_flatten()` comes into play. It takes a character vector as input and combines each element of the vector into a single string.

One variation of `str_flatten()` is `str_flatten_comma()` is a variation designed specifically for flattening with commas. It automatically recognizes if last uses the Oxford comma and handles the special case of 2 elements.



<!--  end the tutorial here-->


### Exercise 15

Using the same AI, ask it to generate code that will collapse our previously made `top_a_1950`, and then split the names into separate rows with `separate_longer_delim()`. In a new code cell below the previous cells, copy and paste the generated code.

Then, isolate the part where `top_a_1950` is collapsed, and either run it in the Console to view the tibble. Then, run the whole thing with the relavant function `separate_longer_delim()` by placing your cursor at the top and pressing `Cmd/Ctrl + Enter`.

CP/CR both tibbles.

```{r strings-15}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 6)
```


###

Our code:

```{r, echo=TRUE}
collapsed <- top_a_1950 |>
  summarize(name_list = str_c(name, collapse = ","))
collapsed
```

```{r, echo=TRUE}
collapsed |>
  separate_longer_delim(name_list, delim = ",")
```

The function `separate_longer_delim(col, delim)` makes the input data frame longer through increased rows, with the string split up through a specified deliminator as an argument.

The function `separate_longer_position(col, width)` makes the input data frame longer through increased rows, with the string split up with specified widths.

### Exercise 16

Using the same AI, ask it to generate code that will separate the first letter of a name from `top_a_1950` from the rest of the name using `separate_wider_position()`. Using the same code cell from the previous exercise, copy and paste the generated code. Then, place your cursor on any line of the code and press `Cmd/Ctrl + Shift + Enter` to run it in the Console. 

CP/CR.

If there is an error, plug it back into AI and see what it says.

```{r strings-16}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 6)
```


###

Our code:

```{r, echo=TRUE}
top_a_1950 |>
  separate_wider_position(
    name,
    widths = c(first_letter = 1, rest_of_name = 100),
    too_few = "align_start"
  )
```

The function `separate_wider_position(col, widths)` makes the input data frame wider through increased columns, with the string split up with a specified widths. Note how because the character length for names varied, we had to pad it with 10 extra characters so we could for sure separate the columns by width.

The function `separate_wider_delim(col, delim, names)` makes the input data frame wider through increased columns, with the string split up with a specified deliminator.

<!-- This knowledge drop seems too long. -->



<!-- LL: This following section could use another exercise for each existing one where students edit the code. Could be too long though? You decide. --> 

### Exercise 17

Make a new code cell after the plot, and using AI, ask it to generate code that pipes **babynames** to `count()` with `str_length()` to find the distribution of lengths of US baby names. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r strings-17}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
``` 


###

Our code:

```{r, echo=TRUE}
babynames |>
  count(length = str_length(name), sort = TRUE)
```

The function `str_length()` tells you the number of letters in the string.


### Exercise 18

Next, get code that pipes `babynames` to `mutate()` and use `str_sub()` to find the first and last letter of each name. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r strings-18}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
``` 


###

Our code:

```{r, echo=TRUE}
babynames |>
  mutate(
    first_letter = str_sub(name, 1, 1),
    last_letter = str_sub(name, -1, -1)
  ) |>
  select(name, first_letter, last_letter)
```

The function `str_sub(string, start, end)` can extract parts of a string. The start and end are the positions where the substring should start and end, and the start and end arguments are inclusive.


### Exercise 19

Next, get code that pipes `babynames` to `filter()` with name and `str_starts()` to find all names beginning with a certain string. Make sure that the pipe is not assigned to any variable so it is easier to run. Copy and paste the code into the same code cell. Place your cursor on the line with the code, and press `Cmd/Ctrl + Enter` to run the code in the Console.

CP/CR.

```{r strings-19}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
``` 


###

Our code:

```{r, echo=TRUE}
babynames |> filter(str_starts(name, "A"))
```

The function `str_starts()` returns TRUE if each string starts with the given pattern. We have used this function earlier in this tutorial! Also, the function `str_ends()` returns TRUE if each string ends with the given pattern. The function `str_detect()` returns TRUE if each string contains the given pattern anywhere inside.


### Exercise 20

Now that we have all these functions in the same code cell, we can see all of the functions we have learned, and we can run any of them at will with `Cmd/Ctrl + Enter`.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r strings-20}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 15)
``` 

### 

Commit/push everything.






## Summary
### 

This tutorial covered [Chapter 12: Logical vectors](https://r4ds.hadley.nz/logicals.html), [Chapter 13: Numbers](https://r4ds.hadley.nz/numbers.html), [Chapter 14: Strings](https://r4ds.hadley.nz/strings.html), [Chapter 15: Regular expressions](https://r4ds.hadley.nz/regexps.html), and [Chapter 16: Factors](https://r4ds.hadley.nz/factors.html), from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. 

You learned about how to work with numbers using commands such as [`pmin()`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Extremes.html) with the **nycflights13** package.

You learned about some of the power of the [**stringr**](https://stringr.tidyverse.org/) package: how to create, combine, and extract strings with the **babynames** package.


### Exercise 1

Publish your rendered QMD to GitHub Pages. In the Terminal --- not the Console! --- run:

````
quarto publish gh-pages analysis.qmd
````

Copy/paste the resulting URL below.

```{r summary-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

Commit/push everything.


```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```



```
STRING KNOWLEDGE DROPS

### 1

You might be wondering what tibble is, A tibble is a new form of a data frame in R that is part of the tidyverse library, and tibbles print the data in a more efficient format than a data frame, showing the values of the columns, their datatype, and the size of the dataset.

### 2

The `babynames` is a data set which contained names used for babies from 1880 to 2017. If you want to explore the data set, checkout [popular baby names](https://www.ssa.gov/oact/babynames/limits.html).### 

### 3

To check for `NA` values, use `any()` function with argument `is.na()`, argument of which should be the dataset babynames. 

### 4

We’ve created strings in passing earlier in the book but didn’t discuss the details. Firstly, you can create a string using either single quotes (') or double quotes ("). If you wanted to include single quotes in a string you could put the outer quotes as double quotes.

Now there’s no difference in behavior between the single quotes and double quotes, but in the interests of consistency, the [*Tidyverse*](https://style.tidyverse.org/syntax.html#character-vectors) style guide recommends using `"`, unless the string itself contains double quotes.

### 5

The **stringr** library is a part of the [*Tidyverse*](https://www.tidyverse.org/). We can just load the **tidyverse** library and the **stringr** library will be automatically loaded. 

### 6

The printed representation of a string is not the same as the string itself because the printed representation shows the escapes. To see the raw contents of the string, we use `str_view()`

### 7

There's another way to include quotes in a string. To include a literal single or double quote, you can use the backslash `\` to escape it. For example, `"\""` will return `'"'`. To include a literal backlash in your string, it is pretty simple and all you need to do is have two backslashes in a string to have one literal one. 

### 8

If you find yourself dealing with a complex situation where you have many backslashes and quotes to include, it can become confusing to keep track of them. (This is sometimes called [leaning toothpick syndrome](https://en.wikipedia.org/wiki/Leaning_toothpick_syndrome).)

To solve the issue, we utilized a raw string, which is a specific type of string literal that doesn't interpret any special characters or escape sequences.

Typically, a raw string starts with `r"(, ends with )"`, and allows for any text representation. However, if the string contains )", alternatives like `r"[]"` or `r"{}"` can be used. Furthermore, you can add dashes to ensure unique opening and closing pairs, such as `r"--()--"`, `r"---()---"`, and so on. Raw strings offer flexibility to handle any text without problems.

### 9

Besides `\"`, `\'`, and `\\`, there are a few other special characters that can be useful. The most common ones are `\n` for a new line and `\t` for a tab. If you want to check out a complete list of other special characters, check out in [Quotes](https://rdrr.io/r/base/Quotes.html).
 
### 10

`str_c()` is a function in the `stringr` package in R that combines multiple character vectors into a single character vector. It is similar to the `paste()` function, but it uses `tidyverse` recycling and NA rules. `str_c()` is vectorized, which means it can take multiple arguments and combine them element-wise. 

### 11

If you are mixing many fixed and variable strings with `str_c()`, you’ll notice that you type a lot of `"`s, making it hard to see the overall goal of the code. An alternative approach is provided by the glue package via `str_glue()`. How `str_glue()` works is that if you give it a single string that has a special feature: anything inside `{}` will be evaluated like it’s outside of the quotes. However, `str_glue()` currently converts missing values to the string "NA" unfortunately making it inconsistent with `str_c()`.

### 12

`str_c()` and `str_glue()` are suitable for use with `mutate()` since their output matches the length of their inputs. However, if you need a function that works well with `summarize()` and always returns a single string, `str_flatten()` comes into play. It takes a character vector as input and combines each element of the vector into a single string.

### 13

One variation of `str_flatten()` is `str_flatten_comma()` is a variation designed specifically for flattening with commas. It automatically recognizes if last uses the Oxford comma and handles the special case of 2 elements.

### 14

The `last` argument is an optional string to use in place of the final separator.

### 15

`summarize()` creates a new data frame. It returns one row for each combination of grouping variables; if there are no grouping variables, the output will have a single row summarizing all observations in the input.

### 16

The `.by` arguement is a selection of columns to group by for just this operation, functioning as an alternative to `group_by()`. For details and examples, see `?dplyr_by`.

To review, `mutate()` either changes an existing column or adds a new one. `summarize()` calculates a single value (per group).

### 17

Separating a string into rows tends to be most useful when the number of components varies from row to row. The most common case is requiring `separate_longer_delim()` to split based on a delimiter.

### 18

Just like with `pivot_longer()` and `pivot_wider()`, `_longer` like `separate_longer_delim()` functions make the input data frame longer by creating new rows and `_wider` functions make the input data frame wider by generating new columns.

### 19

If you are wondering what `delim = ","` means, the `delim` argument is used to specify the delimiter character in functions that involve reading or writing delimited data files.

For example, when reading a CSV (Comma-Separated Values) file using the `read_delim()` function from the **readr** package, you can specify `delim = ","` to indicate that the values in the file are separated by commas. 

### 20

As you look at the tibble, notice we can't separate the numbers by commas to make the column longer. That's where `separate_longer_position()` comes into the play.

### 21

If you don't want a column, all we have to do rename to column to be `NA`

### 22

What if you want to separate them by different width in position? `separate_wider_position()` is the function that solves that.

`separate_wider_position()` works a little differently because you typically want to specify the width of each column. So you give it a named integer vector, where the name gives the name of the new column, and the value is the number of characters it occupies. You can omit values from the output by not naming them

### 23

In response to not having the same number of pieces, there are two possible problems, too few or too many pieces, so `separate_wider_delim()` provides two arguments to help: `too_few` and `too_many`.

### 24

When you use the debug mode, you get three extra columns added to the output: `x_ok`, `x_pieces`, and `x_remainder` (if you separate a variable with a different name, you’ll get a different prefix).

`x_pieces` tells us how many pieces were found, compared to the expected 3 (the length of names). `x_remainder` isn’t useful when there are too few pieces, but we’ll see it again shortly

### 25

In other cases, you may want to fill in the missing pieces with `NA`s and move on. That’s the job of `too_few` = `"align_start"` and `too_few` = `"align_end"` which allow you to control where the `NA`s should go.

### 26

You will get an error and get suggestions to use `too_many = "debug"` or `too_many = "drop/merge"`. We will use "debug" to see what being kept and what's being left and after that we will talk about use drop and merge.

When we debug the result, you can see the purpose of `x_remainder`: it shows what was left behind and not inserted into the columns.

As we are already aware by the word `drop`, it has been established that Rstudio will discard the remaining x remainders.

### 27

`str_length()` tells you the number of letters in the string.

`str_length()` not only counts the letters but also the spaces in between the words in a string. If you want to explore more, check out [`str_length()`](https://stringr.tidyverse.org/reference/str_length.html).

### 28

In RStudio, the `==` operator is used to test for equality between two values. It is a comparison operator that returns a logical value of TRUE if the values are equal and FALSE otherwise. 

### 29

You can extract parts of a string using `str_sub(string, start, end)`, where start and end are the positions where the substring should start and end. 

To extract a substring using the `str_sub()` function, specify the following arguments: the first argument should be the variable `y` that we have defined, the second argument should be the starting position (1 in this case), and the third argument should be the ending position (3 in this case).

Looking at results, when using `str_sub()`The start and end arguments are inclusive, so the length of the returned string will be end - start + 1

If you want to look at the end of the string, you can use negative values to count back from the end of the string: -1 is the last character, -2 is the second to last character, etc. Note that `str_sub()` won’t fail if the string is too short: it will just return as much as possible

### 30

If you didnt know, In Python, indexing starts from zero, whereas in RStudio, indexing starts from one, resulting in a slight variation in accessing elements and slicing sequences.


KNOWLEDGE DROPS FROM tutorials 9, 10, 11

(Not all of them!) Just the 20 or so you think are best. No need to number them.
```
The [**ggrepel**](https://ggrepel.slowkow.com) package will automatically adjust labels so that they don’t overlap. To help others quickly build up a good mental model of the data, you will need to invest considerable effort in making your plots as self-explanatory as possible.

Another handy function for adding annotations to plots is `annotate()`. As a rule of thumb, geoms are generally useful for highlighting a subset of the data while `annotate()` is useful for adding one or few annotation elements to a plot.

We can see that the two plots are the same. Note the naming scheme for scales: `scale_` followed by the name of the aesthetic, then `_`, then the name of the scale. The default scales are named according to the type of variable they align with: `continuous`, `discrete`, `datetime`, or `date`.

Another scale that is frequently customized is color. The default categorical scale picks colors that are evenly spaced around the color wheel. Useful alternatives are the ColorBrewer scales which have been hand-tuned to work better for people with common types of color blindness.

You can use labels in the same way (a character vector the same length as breaks), but you can also set it to NULL to suppress the labels altogether. This can be useful for maps, or for publishing plots where you do want to share the absolute numbers.

In addition to `geom_text()` and `geom_label()`, you have many other geoms in **ggplot2** available to help annotate your plot. For example, you can use `geom_hline()` and `geom_vline()` to add reference lines. We often make them thick (`linewidth = 2`) and white (`color = "white"`), and draw them underneath the primary data layer. That makes them easy to see, without drawing attention away from the data.

As always, `ggplot()` alone, without the use of the `aes()` function as an argument to `mapping`, produces an empty rectangle.



The function, `geom_freqpoly()`, visualizes the distribution of a single continuous variable by dividing the x-axis into bins and counting the number of observations in each bin. Frequency polygons display the counts with lines. Frequency polygons are more suitable when you want to compare the distribution across the levels of a categorical variable.

`geom_bin2d()` and `geom_hex()` divide the coordinate plane into 2d bins and then use a fill color to display how many points fall into each bin. `geom_bin2d()` creates rectangular bins. `geom_hex()` creates hexagonal bins. You will need to install the **hexbin** package to use `geom_hex()`.

If two variables covary, you can use the values of one variable to make better predictions about the values of the second. If the covariation is due to a causal relationship (a special case), then you can use the value of one variable to control the value of the second.

The function [`linear_reg()`](https://parsnip.tidymodels.org/reference/linear_reg.html) defines a model that can predict numeric values from predictors using a linear function. This function can fit regression models. There are different ways to fit this model, and the method of estimation is chosen by setting the model `engine`.

EDA is not a formal process with a strict set of rules. More than anything, EDA is a state of mind. During the initial phases of EDA you should feel free to investigate every idea that occurs to you. Some of these ideas will pan out, and some will be dead ends.

Covariation is the tendency for the values of two or more variables to vary together in a related way. The best way to spot covariation is to visualize the relationship between two or more variables.

If two variables covary, you can use the values of one variable to make better predictions about the values of the second. If the covariation is due to a causal relationship (a special case), then you can use the value of one variable to control the value of the second.


Mapping an unordered discrete (categorical) variable, like `class`, to an ordered aesthetic, like `size` is generally not a good idea because it implies a ranking that does not in fact exist, hence the warning.

Once you map an aesthetic, **ggplot2** takes care of the rest. It selects a reasonable scale to use with the aesthetic, and it constructs a legend that explains the mapping between levels and values. For x and y aesthetics, **ggplot2** does not create a legend, but it creates an axis line with tick marks and a label. The axis line provides the same information as a legend; it explains the mapping between locations and values.

The `geom_smooth()` geom is applied to each category of color separately. With one call to a geom, we get three different plots, all on the same graph. There are no front-wheel drive cars with a `displ` value greater than 5, so the green line does not extend to the right-side of the graphic. 

To facet your plot by a single variable, use `facet_wrap()`. The first argument of `facet_wrap()` is a formula, which you create with `~` followed by a variable name. The variable that you pass to `facet_wrap()` should be categorical, i.e., either character or factor.

Adding randomness seems like a strange way to improve your plot, but while it makes your graph less accurate at small scales, it makes your graph more revealing at large scales. Because this is such a useful operation, **ggplot2** comes with a shorthand for `geom_point(position = "jitter")`: `geom_jitter()`.

We use scale_y_continuous when we want to modify the y-axis for continuous data. [This documentation here](https://ggplot2.tidyverse.org/reference/scale_continuous.html) will tell you more, and all the possible arguments you can use with `scale_y_continuous`

