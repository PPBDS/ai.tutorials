---
title: The First Tutorial for R4DS
author: Luke Li and David Kane
tutorial:
  id: r4ds-1
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: 'This tutorial for "R for Data Science" covers Chapter 1: Data visualization, Chapter 3: Data transformation, Chapter 5: Data tidying, and Chapter 7: Data import.'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)

line_graph <- billboard |>
  filter(track %in% c("Dancing Queen", "Loser", "Try Again")) |>
  pivot_longer(
    cols = wk1:wk5,
    names_to = "week",
    values_to = "rank",
    values_drop_na = TRUE
  ) |>
  ggplot(aes(x = week, y = rank, color = track, group = track)) +
  geom_line() + 
  facet_wrap(~ track)

x <- billboard |>
  filter(wk1 < 101) |>
  arrange(wk1) |>
  mutate(improvement = wk1 - wk2, .after = wk2) |>
  select(artist:improvement) |>
  rename(week1 = wk1, week2 = wk2)

music_1 <- read_csv(
   "data/music.csv",
   col_types = cols_only(
     artist.familiarity = col_character(),
 artist.hotttnesss = col_character(),
 artist.id = col_character()
   )
)

df <- read_csv(
   "data/music.csv",
   col_types = cols(
     artist.familiarity = col_double()
   )
)

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

<!-- DK: Add in the knowledge drops. DONE (for visualization and transformation) -->

<!-- DK: Delete all XX comments. Of course you should read/follow them first. -->

<!-- DK: Introduction/Summary -->


## Introduction
###

<!-- XX: Two to four sentence about the main packages/functions covered in this tutorial. -->

### Exercise 1

Create a Github repo called `r4ds-1`. Make sure to click the "Add a README file" check box.

Connect the repo to a project on your computer using `File -> New Folder from Git ...`.  Make sure to select the "Open in a new window" box. 

You need two Positon windows: this one for running the tutorial and the one you just created for writing your code and interacting with the Console.

In the new window, select `File -> New File -> Quarto Document ...`. Provide a title -- `"Billboards"` -- and an author (you). Render the document and save it as `analysis.qmd`.

Create a `.gitignore` file with `analysis_files` on the first line and then a blank line. Save and push.

In the Console, run:

```         
show_file(".gitignore")
```

If that fails, it is probably because you have not yet loaded `library(tutorial.helpers)` in the Console.

CP/CR.

```{r introduction-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 2

In your QMD, put `library(tidyverse)` in a new code chunk. Render the file using `Cmd/Ctrl + Shift + K`.

Notice that the file does not look good because the code is visible and there are annoying messages. To take care of this, add `#| message: false` to remove all the messages in this `setup` chunk. Also, add the following to the YAML header to remove all code echos from the HTML:

```         
execute: 
  echo: false
```

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r introduction-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 6)
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 3

Place your cursor in the QMD file on the `library(tidyverse)` line. Use `Cmd/Ctrl + Enter` to execute that line.

Note that this causes `library(tidyverse)` to be copied down to the Console and then executed. 

CP/CR.

```{r introduction-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 8)
```

###

Notice how **gplot2** is loaded with **tidyverse**.

R has several systems for making graphs, but [**ggplot2**](https://ggplot2.tidyverse.org/index.html) is one of the most elegant and most versatile. **ggplot2** implements the *grammar of graphics*, a coherent system for describing and building graphs. With **ggplot2**, you can do more and faster by learning one system and applying it in many places.

### Exercise 4

From the Console, run these three commands:

`getwd()`
`dir.create("data")`
`list.files()`

This will create a `data` directory in your project. This is a good place to store any data that you are working with.

CP/CR

```{r introduction-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

You answer should look something like, although your path will be different.

````
> getwd()
[1] "/Users/dkane/Desktop/projects/XX"
> dir.create("data")
> list.files()
 [1] "analysis.qmd"        "data"    "README.md"
>
````


## Billboards
###

The [**billboard**](https://tidyr.tidyverse.org/reference/billboard.html) dataset is a built in dataset from the package [tidyr](https://tidyr.tidyverse.org/index.html). **Billboard** contains data of 317 songs and their weekly song rankings in the Billboard top 100 for 76 weeks after they were released. Almost all of the songs were released in the year 2000, with a few in late 1999, and it was originally obtained from [The "Whitburn" project](https://waxy.org/2008/05/the_whitburn_project/).

We will use these following functions and more for this section:
[ggplot()](https://ggplot2.tidyverse.org/reference/ggplot.html)

[geom_point()](https://ggplot2.tidyverse.org/reference/geom_point.html)

[labs()](https://ggplot2.tidyverse.org/reference/labs.html)

[facet_wrap()](https://ggplot2.tidyverse.org/reference/facet_wrap.html)

[filter()](https://dplyr.tidyverse.org/reference/filter.html)

[arrange()](https://dplyr.tidyverse.org/reference/arrange.html)

[mutate()](https://dplyr.tidyverse.org/reference/mutate.html)

[select()](https://dplyr.tidyverse.org/reference/select.html)

[summarize()](https://dplyr.tidyverse.org/reference/summarise.html)

[slice_head()](https://dplyr.tidyverse.org/reference/slice.html)

<!-- XX: Mention the packages/functions which you plan on covering in this section. Not everything mentioned here is used in the Introduction/Summary, but everything in Introduction/Summary is referenced in one of these Section intro parts, the space before Exercise 1. -->

### Exercise 1

Since we have already loaded **tidyverse**, we have therefore loaded **tidyr**, **ggplot2**, and **dplyr**, some of the component packages of the "core" *Tidyverse*. 

`billboard` is a dataset within **tidyr**.

Type `billboard` into the Console.

CP/CR.


```{r billboards-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

```{r billboards-1-test, echo = TRUE}
billboard
```

###

In the realm of data analysis, a fundamental concept is the notion of a variable. A variable represents a quantity, quality, or property that can be measured or observed. Variables can take different forms, depending on the nature of the data being studied. They can be numeric or categorical, continuous or discrete, qualitative or quantitative.

**Tabular data** is data organized in a table. A table is a group of cells, organized in rows and columns. Tabular data is considered *tidy* if and only if it satisfies the following rules:

1.  Each variable is a column; each column is a variable.
2.  Each observation is a row, each row is an observation.
3.  Each value is a cell, each cell is a single value.

### Exercise 2

In a prompt for AI provide a tibble of `billboard`. You only need the top 3 lines or so.

Ask AI: Create a simple graph plotting `wk1` against `wk2` while only using the functions `ggplot()`, `aes()`, and `geom_point()`. 

Copy and paste the AI generated code into a new code chunk with your QMD. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r billboards-2-test, echo = TRUE}
ggplot(billboard, aes(x = wk1, y = wk2)) +
  geom_point()
```

###

For now, we will be working with functions from the **ggplot2** package.

When you're working with `ggplot()`, you typically won't be using just the `data` **parameter** (input into a function). You'll be using the `mapping` parameter as well. The `mapping` parameter lets you set, among other things, variables for the x- and y-axis.

To use the `mapping` parameter, you have to give `ggplot()` an *aesthetic*, which you get by calling the `aes()` function. For example, if you wanted to set the variable for the x-axis to be `wk1`, you would add `mapping = aes(x = wk1)` in your call to `ggplot()`. 

The aesthetic function, `aes()`, has more parameters than just `x` and `y`. `aes()` has parameters like `color`, `shape`, and `size` as well! You can add them in the same way you added the `x` and `y` parameters: add `color = foo` or `shape = bar(baz)` to your `aes()` call in `ggplot()`. 

See [aesthetic mappings](https://ggplot2.tidyverse.org/reference/aes.html) for more examples.

### Exercise 3

Now, within the code in your QMD, remove the `geom_point()`.

Place your cursor on the line of code and run `Cmd/Ctrl + Enter`.

```{r billboards-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

###

```{r billboards-3-test, echo = TRUE}
ggplot(billboard, aes(x = wk1, y = wk2))
```

###

To display the data points, we need to add a geometric object, or, in ggplot terms, a `geom`. A `geom` is the geometrical object that a plot uses to represent data. These geometric objects are made available in **ggplot2** with functions that start with `geom_`.

`geom_point()` is one of those functions, and it creates a scatterplot which plots the relationship between 2 numerical variables.

###

Revert this change with `Cmd/Ctrl + Z` so that `geom_point()` is restored.

### Exercise 4

Ask AI: Continue the code with `+` and add a trendline with `geom_smooth()`. 

Copy and paste this code to continue the previous code and save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

```{r billboards-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r billboards-4-test, echo = TRUE}
ggplot(billboard, aes(x = wk1, y = wk2)) +
  geom_point() +
  geom_smooth()
```

###

`geom_smooth()` creates a fitted line or curve which can help identify trends and patterns in data. It offers different smoothing methods like linear or polynomial regression and *loess* smoothing. The shaded error around the fitted line represents uncertainty about the estimate.

Within `geom_smooth()`, you can specify the smoothing `method` to be `"lm"`, `"glm"`, or `"loess"`, the specific model `formula` to be a relationship between `y` and `x` like `y ~ x` (default) or `y ~ log(x)`, and `se` to be `TRUE` or `FALSE` to shown the confidence interval for the fitted line or not.

The `"lm"` method stands for **l**inear **m**odel, meaning that R do its best to fit a straight line through the points.

### Exercise 5

Ask AI: Continue the code by adding a `title`, `subtitle`, `caption`, and axis labels using the `labs()` function.

Copy and paste this code to continue the previous code and save the file. Place your cursor on the first line of code again and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r billboards-5-test, echo = TRUE}
ggplot(billboard, aes(x = wk1, y = wk2)) +
  geom_point() +
  geom_smooth() +
  labs(
    title = "Billboard Rankings: Week 1 vs. Week 2",
    subtitle = "Shows how a song’s debut ranking relates to its second week performance",
    caption = "Source: Billboard dataset (2000)",
    x = "Week 1 Rank",
    y = "Week 2 Rank"
  )
```

###

The `labs()` function takes in several arguments to modify the plot labels, including `x`, `y`, `title`, `subtitle`, `caption`, and `tag`. The `x` and `y` arguments are used to modify the axis labels, while the `title`, `subtitle`, and `caption` arguments are used to modify the plot title, subtitle, and caption, respectively. The `tag` argument is used to add a label to the plot that can be used for reference in later code.

The `labs()` function can also be used with the `ggtitle()` function to modify the plot title. This can be useful when you want to have more control over the formatting of the plot title, such as changing the font size or color.

Finally, it's worth noting that the `labs()` function is just one way to modify plot labels in **ggplot2**. Other functions, such as `xlab()`, `ylab()`, and `ggtitle()`, can be used to modify specific plot labels without affecting others. It's important to choose the appropriate function for your needs depending on the level of customization you require.

### Exercise 6

In a new prompt for AI provide a tibble of `billboard` again.

Ask AI: Create a simple graph plotting a line graph showing the rank of 3 songs over the first 5 weeks, mainly using the functions `ggplot()`, `aes()`, and `geom_line()`. 

Copy and paste the AI generated code into a new code chunk with your QMD. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r billboards-6-test, echo = TRUE}
billboard |>
  filter(track %in% c("Dancing Queen", "Loser", "Try Again")) |>
  pivot_longer(
    cols = wk1:wk5,
    names_to = "week",
    values_to = "rank",
    values_drop_na = TRUE
  ) |>
  ggplot(aes(x = week, y = rank, color = track, group = track)) +
  geom_line()
```

###

<!-- LL: is a knowledge drop this in depth about pipes necessary or has it been covered by the introduction tutorial? -->

The code that the AI produced like contained the symbol `%>%` or `|>`, which are pipe operators. We aim to use the `|>` operator because it is a base R function, leading to fewer dependencies and potentially better performance for these simple cases. If your code has `%>%`, replace it with `|>`.

`XX` on the left of the pipe becomes the input to the function on the right side. This generates the same output as `function(data = XX)`. While indentation may not affect how the code performs, it does make the code more readable. We start each command in a pipe on a new line. Each line of code in a pipe ends with the pipe itself: `|>`.

Always keep in mind that steps in the pipeline are separated by `|>` while steps in the construction of your `ggplot()` object are separated with `+`. 

### Exercise 7

Ask AI: Continue the code to split the graph into 3 graphs, 1 per track, using `facet_wrap()`. 

Copy and paste this code to continue the previous code and save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

```{r billboards-7-test, echo = TRUE}
billboard |>
  filter(track %in% c("Dancing Queen", "Loser", "Try Again")) |>
  pivot_longer(
    cols = wk1:wk5,
    names_to = "week",
    values_to = "rank",
    values_drop_na = TRUE
  ) |>
  ggplot(aes(x = week, y = rank, color = track, group = track)) +
  geom_line() + 
  facet_wrap(~ track)
```

###

For categorical variables, splitting your plot into **facets** creates subplots that each display one subset of the data. The first argument of `facet_wrap()` is a formula, which you create with `~` followed by a variable name. The variable that you pass to `facet_wrap()` should be categorical.

### Exercise 8

Provide the AI with your current code.

Ask AI: Continue the code by assigning the plot to the variable `line_graph`, and then save `line_graph` with `ggsave()`.

Copy and paste this code to continue the previous code and save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-8}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

<!-- DK: Change to create an object and then save the object. DONE -->

```{r billboards-8-test, echo = TRUE}
line_graph <- billboard |>
  filter(track %in% c("Dancing Queen", "Loser", "Try Again")) |>
  pivot_longer(
    cols = wk1:wk5,
    names_to = "week",
    values_to = "rank",
    values_drop_na = TRUE
  ) |>
  ggplot(aes(x = week, y = rank, color = track, group = track)) +
  geom_line() + 
  facet_wrap(~ track)

ggsave(filename = "billboard_tracks.png", plot = line_graph)
```

###

In order to save a copy of this plot, we use the [`ggsave()`](https://ggplot2.tidyverse.org/reference/ggsave.html). By default, `ggsave()` saves the most recently created plot, but the argument `plot` allows it to save any plot as long as the plot is assigned to an object.

By default, `ggsave()` saves the PNG file in your current working directory. You can find your current working directory using `getwd()`, and you can set it with `setwd()`.

You can now use the PNG file of the graph anywhere, and the graph is no longer limited to R code.

### Exercise 9

In a new prompt for AI provide a tibble of `billboard` again.

Ask AI: Create a simple graph with boxplots showing the distribution of ranks of 3 songs, mainly using the functions `ggplot()`, `aes()`, and `geom_boxplot()`. 

Copy and paste the AI generated code into a new code chunk with your QMD. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-9}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r billboards-9-test, echo = TRUE}
billboard |>
  filter(track %in% c("Kryptonite", "Loser", "Try Again")) |>
  pivot_longer(
    cols = wk1:wk76,
    names_to = "week",
    values_to = "rank",
    values_drop_na = TRUE
  ) |>
  ggplot(aes(x = track, y = rank)) +
  geom_boxplot()
```

###

<!-- LL: this is too long. How should I shorten? -->

To visualize the relationship between a numerical and a categorical variable we can use side-by-side box plots. A boxplot is a type of visual shorthand for measures of position (percentiles) that describe a distribution. It is also useful for identifying potential outliers. 

A boxplot consists of:

* A box that indicates the range of the middle half of the data, a distance known as the interquartile range (IQR), stretching from the 25th percentile of the distribution to the 75th percentile. In the middle of the box is a line that displays the median, i.e. 50th percentile, of the distribution. These three lines give you a sense of the spread of the distribution and whether or not the distribution is symmetric about the median or skewed to one side.

* Visual points that display observations that fall more than 1.5 times the IQR from either edge of the box. These outlying points are unusual so are plotted individually.

* A line (or whisker) that extends from each end of the box and goes to the farthest non-outlier point in the distribution.

### Exercise 10

In a new prompt for AI provide a tibble of `billboard` again.

Ask AI: Create a simple bar graph with bars showing the count of weeks 3 songs were ranked in the top 100, mainly using the functions `ggplot()`, `aes()`, and `geom_bar()`. 

Copy and paste the AI generated code into a new code chunk with your QMD. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-10}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r billboards-10-test, echo = TRUE}
billboard |>
  filter(track %in% c("Kryptonite", "Loser", "Try Again")) |>
  pivot_longer(
    cols = wk1:wk76,
    names_to = "week",
    values_to = "rank",
    values_drop_na = TRUE
  ) |>
  filter(rank <= 100) |>
  ggplot(aes(x = track)) +
  geom_bar()
```

###

`geom_bar()` makes the height of the bar proportional to the number of cases in each group. If you want the heights of the bars to represent values in the data, use `geom_col()` instead. `geom_bar()` uses `stat_count()` by default: it counts the number of cases at each x position. `geom_col()` uses `stat_identity()`: it leaves the data as is.

### Exercise 11

Now, we'll move onto functions from the **dplyr** package.

In a new prompt for AI provide a tibble of `billboard` again.

Ask AI: Create a pipe with `billboard` to filter for the rows where the values in `wk1` are less than 101.

Copy and paste the AI generated code into a new code chunk with your QMD. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-11}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r billboards-11-test, echo = TRUE}
billboard |>
  filter(wk1 < 101)
```

###

`filter()` changes which rows are present without changing their order. When you run `filter()`, **dplyr** executes the filtering operation, creating a new data frame, and then prints it. It doesn’t modify the existing flights dataset because **dplyr** functions never modify their inputs.

You can use boolean logic when filtering. For example, `&` means *and* and `|` means *or*. `==` tests for equality while `=` leads to an error. Also, there’s a useful shortcut when you’re combining `|` and `==`: `%in%`. It keeps rows where the variable equals one of the values on the right. 


### Exercise 12

Ask AI: Continue the pipe with `billboard` to arrange the rows by `wk1` rank values.

If your using a different AI, provide the `billboard` tibble again and the previous code.

Copy and paste the AI generated code in the place to continue the previous code. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-12}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r billboards-12-test, echo = TRUE}
billboard |>
  filter(wk1 < 101) |>
  arrange(wk1)
```

###

`arrange()` changes the order of the rows based on the value of the columns. It takes a data frame and a set of column names (or more complicated expressions) to order by. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns. 

### Exercise 13

Ask AI: Continue the pipe with `billboard` to create a new column titled `improvement` that contains the difference between `wk1` and `wk2` rankings, and place it after the `wk2` column.

If your using a different AI, provide the `billboard` tibble again and the previous code.

Copy and paste the AI generated code in the place to continue the previous code. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-13}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r billboards-13-test, echo = TRUE}
billboard |>
  filter(wk1 < 101) |>
  arrange(wk1) |>
  mutate(improvement = wk1 - wk2, .after = wk2)
```

###

`mutate()` creates new columns that are derived from the existing columns. 

The `.` is a sign that `.after` is an argument to the function, not the name of a third new variable we are creating.

`.after`, like .`before` and many **tidyverse** functions, uses the [`<tidy-select>`](https://dplyr.tidyverse.org/reference/dplyr_tidy_select.html) argument modifier which enables multiple ways of selecting columns other than just providing a column name.


### Exercise 14

Ask AI: Continue the pipe with `billboard` to select the columns `artist` through `improvement`.

If your using a different AI, provide the `billboard` tibble again and the previous code.

Copy and paste the AI generated code in the place to continue the previous code. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-14}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r billboards-14-test, echo = TRUE}
billboard |>
  filter(wk1 < 101) |>
  arrange(wk1) |>
  mutate(improvement = wk1 - wk2, .after = wk2) |>
  select(artist:improvement)
```

###

`select()` changes which columns to include from the current data frame in the new data frame.

From the `select()` [help page](https://dplyr.tidyverse.org/reference/select.html):

Tidyverse selections implement a dialect of R where operators make it easy to select variables:

* `:` for selecting a range of consecutive variables.

* `!` for taking the complement of a set of variables.

* `&` and `|` for selecting the intersection or the union of two sets of variables.

* `c()` for combining selections.

There are a number of helper functions you can use within `select()`:

* `starts_with("abc")`: matches names that begin with “abc”.
* `ends_with("xyz")`: matches names that end with “xyz”.
* `contains("ijk")`: matches names that contain “ijk”.
* `num_range("x", 1:3)`: matches x1, x2 and x3.

### Exercise 15

Ask AI: Continue the pipe with `billboard` to rename the columns `wk1` and `wk2` to be `week1` and `week2` respectively.

If your using a different AI, provide the `billboard` tibble again and the previous code.

Copy and paste the AI generated code in the place to continue the previous code. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-15}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r billboards-15-test, echo = TRUE}
billboard |>
  filter(wk1 < 101) |>
  arrange(wk1) |>
  mutate(improvement = wk1 - wk2, .after = wk2) |>
  select(artist:improvement) |>
  rename(week1 = wk1, week2 = wk2)
```

###

`rename()` changes the names of the columns with no impact on the other variables.

You can also rename variables as you `select()` them by using `=`. The new name appears on the left hand side of the `=`, and the old variable appears on the right hand side. 

<!-- LL: should I add an exercise for group_by() even if we would rather only use the .by argument in summarize() in the future? -->

### Exercise 16

Ask AI: Continue the pipe with `billboard` to make a new column titled `week1tens` that takes the values in `week1` and makes them the multiple of ten that they belong to. For example, 87 becomes 80, 72 becomes 70, etc. Then, group the data by `week1tens` values and make a new column titled `averageimprovement` that takes the mean from `improvement`. Use `summarize()` with the `.by` argument instead of `group_by()`. Make sure to drop NA values.

If your using a different AI, provide the `billboard` tibble again and the previous code.

Copy and paste the AI generated code in the place to continue the previous code. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-16}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

```{r billboards-16-test, echo = TRUE}
billboard |>
  filter(wk1 < 101) |>
  arrange(wk1) |>
  mutate(improvement = wk1 - wk2, .after = wk2) |>
  select(artist:improvement) |>
  rename(week1 = wk1, week2 = wk2) |>
  mutate(week1tens = floor(week1 / 10) * 10) |>
  summarize(
    averageimprovement = mean(improvement, na.rm = TRUE),
    .by = week1tens
  )
```

###

The funciton `summarize()`, if being used to calculate a single summary statistic, reduces the data frame to have a single row for each group, and also reduces columns to the group and the statistic.

Almost all statistical functions in R produce an `NA` result by default if any of the input values are `NA`. We can ignore the `NA` values when using `mean()` by adding `na.rm = TRUE` to `mean()` or any calculation function.

Note that the argument `.by` is a relatively new addition to **dplyr** functions. In the past, to calculate group statistics you needed to issue the `group_by()` command in the pipe before the call to `summarize()`.

Using `.by` is a much better approach. Never use `group_by()` unless you have a really good reason to do so.

### Exercise 17

Now, remove the newly created part of the pipe so that the pipe should be the code that we had before exercise 16.

Ask AI: Continue the pipe with `billboard` to slice the data for the top 5 songs by `improvement`.

If your using a different AI, provide the `billboard` tibble again and the previous code.

Copy and paste the AI generated code in the place to continue the previous code. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r billboards-17}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

```{r billboards-17-test, echo = TRUE}
billboard |>
  filter(wk1 < 101) |>
  arrange(wk1) |>
  mutate(improvement = wk1 - wk2, .after = wk2) |>
  select(artist:improvement) |>
  rename(week1 = wk1, week2 = wk2) |>
  slice_max(improvement, n = 5)
```

###

There are five handy functions, all part of the [`slice_*()`](https://dplyr.tidyverse.org/reference/slice.html) family, that allow you to extract specific rows.

### Exercise 18

Before creating a plot, we need to ensure that your data matches our data. In the QMD, replace your code from the previous exercise with our code.

Now, edit it so that the `slice_max()` function is removed from the pipe.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r billboards-18}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 6)
```

###

A function we didn't talk about was `relocate()`. We use `relocate()` to move variables around. You might want to collect related variables together or move important variables to the front of your tibble. By default `relocate()` moves variables to the front. 

We also didn't talk about `distinct()`. `distinct()` finds all the unique rows in a dataset and primarily operates on the rows. If you want to find the number of occurrences instead use  `count()` with the `sort = TRUE` argument which will arrange them in descending order of number of occurrences

### Exercise 19

Within the latest code chunk, add the option: `#| cache: true`. Assign the result of the pipe to `x`. 

`Cmd/Ctrl + Shift + K`. By including `#| cache: true` you cause Quarto to cache the results of the chunk. The next time you render your QMD, as long as you have not changed the code, Quarto will just load up the saved object.

If you have not done so already, you should add `analysis_cache` to the `.gitginore`. The content of the cache file does not belong on GitHub.

Place your cursor on the line where the pipe is assigned to `x`, run `Cmd/Ctrl + Enter`, thus ensuring that the workspace also includes a copy of `x`.

CP/CR.

```{r billboards-19}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 8)
```

###

Our code:

```{r, echo = TRUE}
x <- billboard |>
  filter(wk1 < 101) |>
  arrange(wk1) |>
  mutate(improvement = wk1 - wk2, .after = wk2) |>
  select(artist:improvement) |>
  rename(week1 = wk1, week2 = wk2)
```

###

The pipe takes the thing on its left and passes it along to the function on its right so that `billboard |> filter(wk1 < 101)` is equivalent to `filter(billboard, wk1 < 101)`, and `billboard |> filter(wk1 < 101) |> arrange(wk1)` is equivalent to `arrange(filter(billboard, wk1 < 101), wk1)`. The easiest way to pronounce the pipe is “then”.

### Exercise 20

Within the Console, type `x`, which we previously assigned to a pipe and ran in the Console. Hit `Enter`.

CP/CR.

```{r billboards-20}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 8)
```

###

Our code:

```{r, echo=TRUE}
x
```

###

`billboard` is a tibble, a special type of data frame used by the tidyverse to avoid some common gotchas. The most important difference between tibbles and data frames is the way tibbles print; they are designed for large datasets, so they only show the first few rows and only the columns that fit on one screen.

`x` is also a tibble as **tidyverse** functions return tibbles by default.

### Exercise 21

Ask AI: generate R code that uses `x` to plot a basic graph showing a histogram for `improvement`. Mention you want to use the data from `x` and copy/paste the `x` you ran in the Console with the resulting tibble. You only need the top 3 lines, mainly to include column names.

Within `labs()`, edit or add a proper title, subtitle, and caption. If axis labels would be useful, add them, but if unnecessary, don't bother. Don't assign the code for the plot to any variable. Put the plot code in a new code chunk. Run `Cmd/Ctrl + Shift + K` to ensure that everything works. 

Make your plot look nice. Edit the appearance by hand or get AI to help. The titles should be legible and everything should have proper capitalization.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r billboards-21}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 12)
```

###

Our code:

```{r, echo=TRUE}
ggplot(x, aes(x = improvement)) +
  geom_histogram(binwidth = 5, fill = "skyblue", color = "black") + 
  labs(
	title = "Distribution of Billboard Top 100 Song Ranking Improvements From Week 1 to Week 2",
	subtitle = "Most songs either had no improvement or improved their ranking by up to 20 places",
	x = "Song Rank Improvement",
	y = "Count",
	caption = "Source: Song rankings for Billboard top 100 in the year 2000"
  ) +
  theme(
    plot.title = element_text(size = 7.5, face = "bold"),
    plot.subtitle = element_text(size = 8)
  )
```

###

<!-- XX: Make sure your plotting code is good! This will take some time. You had better have a subtitle which provides the take-away message of the plot. AI sometimes gives you too much code, lots of `theme()` stuff and so on. This is no good! In most cases, we are happy with concise, straightforward code. Insert a knowledge drop related to this project. -->

<!-- LL: I want to income theme() so that students get used to making their plots look nice. Or should I drop the theme()? -->

A histogram divides the x-axis into equally spaced bins and then uses the height of a bar to display the number of observations that fall in each bin. You can set the width of the intervals in a histogram with the `binwidth` argument, which is measured in the units of the x variable. 

An alternative visualization for distributions of numerical variables is a density plot. A density plot is a smoothed-out version of a histogram and a practical alternative, particularly for continuous data that comes from an underlying smooth distribution. 

````
VISUALIZATION remaining knowledge drops

### 

In **ggplot2**, when aesthetic mappings are defined at the global level, they are passed down to all subsequent geom layers in the plot. However, each geom function in **ggplot2** can also accept a mapping argument, allowing for local-level aesthetic mappings that are added to those inherited from the global level.

###

A histogram divides the x-axis into equally spaced bins and then uses the height of a bar to display the number of observations that fall in each bin. You can set the width of the intervals in a histogram with the `binwidth` argument, which is measured in the units of the x variable. 

An alternative visualization for distributions of numerical variables is a density plot. A density plot is a smoothed-out version of a histogram and a practical alternative, particularly for continuous data that comes from an underlying smooth distribution. 

###

We can use stacked bar plots to visualize the relationship between two categorical variables while a scatterplot is probably the most commonly used plot for visualizing the relationship between two numerical variables.

TRANSFOMRATION remaining knowledge drops

### 

The four allowed values for `.keep` are `"all"`, `"used"`, `"unused"`, and `"none"`. Look at the `mutate()` [help page](https://dplyr.tidyverse.org/reference/mutate.html).

* "all" retains all columns from `.data`. This is the default.

* "used" retains only the columns used in `...` to create new columns. This is useful for checking your work, as it displays inputs and outputs side-by-side.

* "unused" retains only the columns not used in `...` to create new columns. This is useful if you generate new columns, but no longer need the columns used to generate them.

* "none" doesn't retain any extra columns from `.data`. Only the grouping variables and columns created by `...` are kept.
````


## Music
###

The **music** CSV file comes from the [**Million Song Dataset**](https://corgis-edu.github.io/corgis/csv/music/), which used a company called the Echo Nest to derive data points about one million popular contemporary songs. **Music** only contains 10,000 rows of data of the songs from the **Million Song Dataset**.

<!-- XX: Mention the packages/functions which you plan on covering in this section. Not everything mentioned here is used in the Introduction/Summary, but everything in Introduction/Summary is referended in one of these Section intro parts, the space before Exercise 1. -->

### Exercise 1

We begin by downloading our CSV file `data/music.csv` directly from the internet using `download.file()`. 

This adds the spreadsheet, `data/music.csv`, to our the `data` directory so we can use it in this tutorial.

In the Console, run:

```         
download.file(
  "https://corgis-edu.github.io/corgis/datasets/csv/music/music.csv",
  destfile = "data/music.csv"
)
```

CP/CR.

```{r music-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

"CSV" stands for **c**omma-**s**eparated **v**alues, meaning that the variable names and data values are separated by commas in the file. CSV files are just one type of **text** file. A text file is any file which includes plain text. The contents of such files are easy to look at in any text editor, or in RStudio.

### Exercise 2

Ask AI: Read a `.csv` dataset called `data/music.csv` using `read_csv()`. 

Add this code to a new code chunk in your QMD. Make sure the code is not assigned to a variable. 

Place your cursor at the beginning of the line and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r music-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

###

Our code:

```{r music-2-test, echo = TRUE, eval = FALSE}
read_csv("data/music.csv")
```

###

When you run `read_csv()`, it prints out a message telling you the number of rows and columns of data, the delimiter that was used, and the column specifications (names of columns organized by the type of data the column contains). It also prints out some information about retrieving the full column specification and how to quiet this message. 

Once you’ve mastered read_csv(), using readr’s other functions is straightforward; it’s just a matter of knowing which function to reach for:

read_csv2() reads semicolon-separated files. These use ; instead of , to separate fields and are common in countries that use , as the decimal marker.

read_tsv() reads tab-delimited files.

read_delim() reads in files with any delimiter, attempting to automatically guess the delimiter if you don’t specify it.

read_fwf() reads fixed-width files. You can specify fields by their widths with fwf_widths() or by their positions with fwf_positions().

read_table() reads a common variation of fixed-width files where columns are separated by white space.

read_log() reads Apache-style log files.

### Exercise 3

Provide AI with the line of code from the question above, as well as the tibble of data.

Ask AI: Edit the code so that the `read_csv()` skips the first 5 lines.

Copy and paste the AI generated code in the place to edit the previous code. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r music-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r music-3-test, echo = TRUE}
read_csv("data/music.csv", skip = 5)
```

###

The argument `skip` is used to skip rows, but to skip columns, you can use the `col_only()` function as the argument to `col_types` in order to read in only the columns which you want. 

### Exercise 4

Ask AI: Edit the code so that the `read_csv()` will also not read the first row as headings.

If your using a different AI, provide the `music.csv` tibble again and the previous code.

Copy and paste the AI generated code in the place to edit the previous code. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r music-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r music-4-test, echo = TRUE}
read_csv("data/music.csv", skip = 5, col_names = FALSE)
```

###

If you are in a future case where columns are surrounded by backticks. That’s because they contain spaces, breaking R’s usual rules for variable names; they’re *non-syntactic* names. To refer to these variables, you need to surround them with backticks: `` ` ``. 

###

Sometimes, a data set will have scores of weirdly named variables. In that case, we recommend using `clean_names()` from the [**janitor**](https://sfirke.github.io/janitor/) package. 

**janitor** has several useful functions, including `make_clean_names()`, which does the same thing as `clean_names()` but can be used directly during data import rather than as part of a pipe.

`clean_names()` not only fixes the *non-syntactic* names like `Full Name`; it also cleans up any variable name which does not follow the standard approach of, first, no capitalization and, second, using underscores as a word seperator.

The **janitor** package has a function called `remove_empty()` to remove empty spaces, `remove_constant()` to remove columns of constant values, and many more. 

### Exercise 5

Ask AI: Edit the code so that the `read_csv()` instead changes the first 3 column names to be replaced by a character vector of 1, 2, and 3.

If your using a different AI, provide the `music.csv` tibble again and the previous code.

Copy and paste the AI generated code in the place to edit the previous code. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r music-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r music-5-test, echo = TRUE}
read_csv("data/music.csv", skip = 5, 
         col_names = c("1", "2", "3"))
```

###


The argument `col_names` can also be used to create custom column names. 

The `col_names` argument is not just specific to `read_csv()`; it can be used in other functions such as `read_excel()` and `read_delim()`

There are many other arguments to `cols`. Type `?cols` into your Console to explore!

<!-- LL: in an email you said "no warnings about col_types". Does that mean no questions regarding the argument? Should we teach students how to debug if an automatically generated column type is incorrect? -->

### Exercise 6

Ask AI: Edit the code so that the `skip` and `col_names` arguments are removed, and that the `read_csv()` is assigned to an object `df` and `read_csv()` is told with `col_types` that the column type of `artist.familiarity` is a double and to check if it fails. Then run `problems(df)`.

If your using a different AI, provide the `music.csv` tibble again and the previous code.

Copy and paste the AI generated code in the place to edit the previous code. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r music-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r music-6-test, echo = TRUE}
df <- read_csv(
   "data/music.csv",
   col_types = cols(
     artist.familiarity = col_double()
   )
)
 
problems(df)
```

###

A CSV file doesn’t contain any information about the type of each variable (i.e. whether it’s a logical, number, string, etc.), so **readr** will try to guess the type. 

**readr** uses a heuristic to figure out the column types. For each column, it pulls the values of 1,000 rows spaced evenly from the first row to the last, ignoring missing values. It then works through the following questions:

* Does it contain only `F`, `T`, `FALSE`, or `TRUE` (ignoring case)? If so, it’s a logical.
* Does it contain only numbers (e.g., `1`, `-4.5`, `5e6`, `Inf`)? If so, it’s a number.
* Does it match the ISO8601 standard? If so, it’s a date or date-time. 
* Otherwise, it must be a string.

It is always better to use the `col_types` argument explicitly in order to ensure that the variable types are what you want them to be. 

###

Now delete `df` along with the code. The chunk should be empty.

### Exercise 7

Ask AI: Edit the code `read_csv("data/music.csv")` so that the `read_csv()` only selects the columns `artist.familiarity`, `artist.hotttnesss`, and `artist.id` with `cols_only()`, and then overrides the code type to be a string.

If your using a different AI, provide the `music.csv` tibble again and the previous code.

Copy and paste the AI generated code into the empty chunk. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r music-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r music-7-test, echo = TRUE}
read_csv(
  "data/music.csv",
  col_types = cols_only(
    artist.familiarity = col_character(),
	artist.hotttnesss = col_character(),
	artist.id = col_character()
  )
)
```

###

Assign this code to the object `music_1`.

###

**readr** provides a total of nine column types for you to use. Here are the most important 4.

* `col_logical()` and `col_double()` read logicals and real numbers. They’re relatively rarely needed (except as above), since **readr** will usually guess them for you.

* `col_integer()` reads integers. We seldom distinguish integers and doubles because they’re functionally equivalent, but reading integers explicitly can occasionally be useful because they occupy half the memory of doubles.

* `col_character()` reads strings. This is sometimes useful to specify explicitly when you have a column that is a numeric identifier, i.e. long series of digits that identifies some object, but it doesn’t make sense to (e.g.) divide it in half, for example, a phone number, social security number, credit card number, etc.

The [help page](https://readr.tidyverse.org/reference/cols.html) for `cols()` includes more details and discussion.

### Exercise 8

Provide AI with a tibble of `music_1`.

Ask AI: Based off of the `music_1` tibble previously provided, create a similar tibble with only 3 rows of data using `tibble()`, and with the same 3 columns. Don't assign the tibble to an object.

Copy and paste the AI generated code below the previous code. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r music-8}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r music-8-test, echo = TRUE}
tibble(
  artist.familiarity = c("0.85", "0.67", "0.92"),
  artist.hotttnesss  = c("0.78", "0.55", "0.88"),
  artist.id          = c("AR123", "AR456", "AR789")
)
```

###

Sometimes you’ll need to assemble a tibble “by hand,” doing a little data entry in your R script. There are two useful functions to help you do this which differ in whether you layout the tibble by columns [`tibble()`](https://tibble.tidyverse.org/reference/tibble.html) or by rows [`tribble()`](https://tibble.tidyverse.org/reference/tribble.html).

### Exercise 9

Ask AI: Continue the previous code with the new tibble so that it is fed through a pipe and is written into a new CSV file titled `music_fake.csv` within the `data` directory.

If your using a different AI, provide the previous code.

Manually, using the same command, do the same for the `music_1` tibble.

<!-- LL: is this too messy? -->

Copy and paste the AI generated code into the appropriate place. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r music-9}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r music-9-test, echo = TRUE}
tibble(
  artist.familiarity = c("0.85", "0.67", "0.92"),
  artist.hotttnesss  = c("0.78", "0.55", "0.88"),
  artist.id          = c("AR123", "AR456", "AR789")
) |>
  write_csv("data/music_fake.csv")

write_csv(music_1, "data/music_1.csv")
```

###

**readr** also comes with two useful functions for writing data back to disk: `write_csv()` and `write_tsv()`. The most important arguments to these functions are `x` (the data frame or tibble to write) and `file` (the location to write it to). You can also specify how missing values are written with `na`, and if you want to `append` to an existing file.

### Exercise 10

Ask AI: Creating a vector of both CSV files, use `read_csv()` to read both CSV files `"music_1.csv"` and `"music_fake.csv"` and create a new column showing the file that the data comes from with the argument `id`. Don't assign the combined data frame to an object.

If your using a different AI, provide the `music.csv` tibble again and the previous code.

Copy and paste the AI generated code in the place following the previous code. Run `Cmd/Ctrl + S` to save the file. Place your cursor on the first line of code and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r music-10}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r music-10-test, echo = TRUE}
read_csv(c("data/music_1.csv", "data/music_fake.csv"), id = "file")
```

###

With `read_csv()` you can read these multiple CSV files in at once and stack them on top of each other in a single data frame. The code above will only work if you have the CSV files in a data folder in your project.

###

Now, delete all code and rewrite `read_csv("data/music.csv")`. That is all that should remain.

<!-- LL: should I ask them to delete all previous code? They could reference it in the future but also it would be too messy.  -->

### Exercise 11

<!-- XX: The end of a Section always finishes up with a plot. These four questions set up and then guide the student to creating that plot. If you want the student to mimic a plot, you can place it in the `images` subdirectory and then use knitr::include_graphics("images/plot.png") to show it to students. -->

Before creating a plot, we need to ensure that your data matches our data. In the QMD, replace your code from the previous exercise with our code.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r music-11}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 6)
```

###

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 12

Within the latest code chunk, add the option: `#| cache: true`. Assign the result of the pipe to `x`. 

`Cmd/Ctrl + Shift + K`. By including `#| cache: true` you cause Quarto to cache the results of the chunk. The next time you render your QMD, as long as you have not changed the code, Quarto will just load up the saved object.

If you have not done so already, you should add `analysis_cache` to the `.gitginore`. The content of the cache file does not belong on GitHub.

Place your cursor on the line where the pipe is assigned to `x`, run `Cmd/Ctrl + Enter`, thus ensuring that the workspace also includes a copy of `x`.

CP/CR.

```{r music-12}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 8)
```

###

Our code:

```{r, echo = TRUE}
#x <- ...
```

###

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 13

Within the Console, type `x`, which we previously assigned to a pipe and ran in the Console. Hit `Enter`.

CP/CR.

```{r music-13}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 8)
```

###

Our code:

```{r, echo=TRUE}
#x
#...
```

###

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 14

Ask AI to generate R code that uses `x` to plot a basic graph showing XX... Mention you want to use the data from `x` and copy/paste the `x` you ran in the Console with the resulting tibble. You only need the top 3 lines, mainly to include column names.

Within `labs()`, edit or add a proper title, subtitle, and caption. If axis labels would be useful, add them, but if unnecessary, don't bother. Don't assign the code for the plot to any variable. Put the plot code in a new code chunk. Run `Cmd/Ctrl + Shift + K` to ensure that everything works. Make your plot look nice.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r music-14}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 12)
```

###

Our code:

```{r, echo=TRUE}
  #...
```

###

<!-- XX: Make sure your plotting code is good! This will take some time. You had better have a subtitle which provides the take-away message of the plot. AI sometimes gives you too much code, lots of `theme()` stuff and so on. This is no good! In most cases, we are happy with concise, straightforward code. Insert a knowledge drop related to this project. -->

````
IMPORT remaining knowledge drops

### 

This tutorial covers [Chapter 7: Data import](https://r4ds.hadley.nz/data-import.html) from [*R for Data Science (2e)*](https://r4ds.hadley.nz/) by Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund. You will learn how to import data into your R project using [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.html) and related functions from the [**readr**](https://readr.tidyverse.org/) package. You will also learn how to write out data to files with functions like [`write_csv()`](https://readr.tidyverse.org/reference/write_delim.html).

###

There are functions which specify data: `col_logical()`, `col_double()`, `col_date()`, and so on.

###

The "quotation trick" allows `read_csv()` and related functions to read data directly from a quoted string, rather than a file. 
It produces the same tibble as if the character string were in a separate file.

### 

Here are the other 5 column types from **readr**.

* `col_factor()`, `col_date()`, and `col_datetime()` create factors, dates, and date-times respectively.

* `col_number()` is a permissive numeric parser that will ignore non-numeric components, and is particularly useful for currencies.

* `col_skip()` skips a column so it’s not included in the result, which can be useful for speeding up reading the data if you have a large CSV file and you only want to use some of the columns.
````

## Summary
###

<!-- XX: The exact same two to four sentence about the main packages/functions used in the Introduction, but written here in the past tense. You made a promise and you kept it.  -->

### Exercise 1

`Cmd/Ctrl + Shift + K` to ensure that everything works.  The resulting HTML page should be attractive, showing clean versions of your plots.

At the Console, run:

```
tutorial.helpers::show_file("analysis.qmd")
```

CP/CR.

```{r summary-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 30)
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 2

Publish your rendered QMD to GitHub Pages. In the Terminal --- not the Console! --- run:

````
quarto publish gh-pages XX.qmd
````

Copy/paste the resulting URL below.

```{r summary-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 1)
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 3

Commit and push all your files. Copy/paste the URL to your Github repo.

```{r summary-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

<!-- XX: The tutorial is now over. Add any necessary acknowledgements and/or provide a link to further high quality readings, ideally readings which you mentioned in at least one knowledge drop above. -->

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
