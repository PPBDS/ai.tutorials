---
title: A Fifth Tutorial for R4DS
author: Sruthi Gandhi and David Kane
tutorial:
  id: r4ds-5
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description:  'This tutorial for "R for Data Science" covers Chapter 23: Hierarchical Data, Chapter 24: Web Scraping, Chapter 25: Functions, and Chapter 26: Iterations.'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)

library(leaflet)

knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

convert_earthquake_time <- function(milliseconds) {
   as.POSIXct(milliseconds / 1000, origin = "1970-01-01", tz = "UTC")
 }
categorize_magnitude <- function(mag) {
   case_when(
     mag < 3.0 ~ "Minor",
     mag < 4.0 ~ "Light", 
    mag < 5.0 ~ "Moderate",
     mag < 6.0 ~ "Strong",
     mag < 7.0 ~ "Major",
     TRUE ~ "Great"
   )
 }

earthquake_df <- jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_") |> 
  hoist(geometry, coordinates = "coordinates") |> 
  unnest_wider(coordinates, names_sep = "_") |> 
  rename(
    longitude = coordinates_1,
    latitude  = coordinates_2,
    depth     = coordinates_3
  )|>
 	mutate(across(where(is.character), ~ifelse(.x == "null", NA, .x))) |>
 	filter(!if_any(c(properties_mag, longitude, latitude), is.na))|>
		mutate(
  			datetime = convert_earthquake_time(as.numeric(properties_time)),
  			mag_category = categorize_magnitude(as.numeric(properties_mag))
		)|>
mutate(across(c(properties_mag, depth), as.numeric)) |>
  filter(datetime >= Sys.Date() - 7) |>
  filter(longitude >= -125, longitude <= -66, latitude >= 20, latitude <= 50) |>
  mutate(
    hour = hour(datetime),
    day_of_week = wday(datetime, label = TRUE),
    depth_category = case_when(
      depth < 70 ~ "Shallow",
      depth < 300 ~ "Intermediate", 
      depth < 600 ~ "Deep"
    )
  )|>
  select(longitude, latitude, properties_mag, properties_place, datetime, depth, mag_category, depth_category) |>
  mutate(
    tooltip_text = paste0(
      "Magnitude: ", properties_mag, " (", mag_category, ")<br>",
      "Location: ", properties_place, "<br>",
      "Time: ", format(datetime, "%Y-%m-%d %H:%M"), "<br>",
      "Depth: ", round(depth, 1), " km (", depth_category, ")"
    )
  )|>
  filter(
    longitude >= -180, longitude <= 180,
    latitude >= -90, latitude <= 90,
    properties_mag >= 0, properties_mag <= 10
  ) |>
  mutate(
    color = case_when(
      properties_mag >= 6 ~ "red",
      properties_mag >= 5 ~ "orange", 
      properties_mag >= 4 ~ "yellow",
      properties_mag >= 3 ~ "green",
      TRUE ~ "blue"
    )
  ) |>
  arrange(desc(properties_mag))
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

<!-- XX: CHECKLIST BEFORE STARTING: -->
<!-- * If you need to use the copy code button, you must load the relevant child document. -->
<!-- * Use check_current_tutorial() and make_exercise(). Very helpful! -->
<!-- * Edit yaml at the top of this file -->
<!-- * Save the file as "tutorial.Rmd" in the correct directory under inst/tutorials/. -->
<!-- * Load any necessary libraries for the tutorial in the first code chunk -->
<!-- * Anytime to have a student `Cmd/Ctrl + Enter`, you ask for CP/CR and then provide your code. -->
<!-- * Delete this and the other commented instructions below. -->

## Introduction
###

<!-- XX: Two to four sentence about the main packages/functions covered in this tutorial. -->

### Exercise 1

Create a Github repo called `XX`. Make sure to click the "Add a README file" check box.

Connect the repo to a project on your computer using `File -> New Folder from Git ...`.  Make sure to select the "Open in a new window" box. 

You need two Positon windows: this one for running the tutorial and the one you just created for writing your code and interacting with the Console.

In the new window, select `File -> New File -> Quarto Document ...`. Provide a title -- `"XX"` -- and an author (you). Render the document and save it as `analysis.qmd`.

Create a `.gitignore` file with `analysis_files` on the first line and then a blank line. Save and push.

In the Console, run:

```         
show_file(".gitignore")
```

If that fails, it is probably because you have not yet loaded `library(tutorial.helpers)` in the Console.

CP/CR.

```{r introduction-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 2

In your QMD, put `library(tidyverse)` in a new code chunk. Render the file using `Cmd/Ctrl + Shift + K`.

Notice that the file does not look good because the code is visible and there are annoying messages. To take care of this, add `#| message: false` to remove all the messages in this `setup` chunk. Also, add the following to the YAML header to remove all code echos from the HTML:

```         
execute: 
  echo: false
```

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r introduction-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 6)
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 3

Place your cursor in the QMD file on the `library(tidyverse)` line. Use `Cmd/Ctrl + Enter` to execute that line.

Note that this causes `library(tidyverse)` to be copied down to the Console and then executed. 

CP/CR.

```{r introduction-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 8)
```

###

<!-- XX: Insert a knowledge drop related to this project. -->


### Exercise 4

<!-- XX: Delete this question if you do not make use of the `data` directory in this tutorial. -->

From the Console, run these three commands:

`getwd()`
`dir.create("data")`
`list.files()`

This will create a `data` directory in your project. This is a good place to store any data that you are working with.

CP/CR

```{r introduction-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

You answer should look something like, although your path will be different.

````
> getwd()
[1] "/Users/dkane/Desktop/projects/XX"
> dir.create("data")
> list.files()
 [1] "analysis.qmd"        "data"    "README.md"
>
````



<!-- XX: You will probably have two or three Sections, in between the Introduction and Summary. We provide on example below. Before editing it, you may want to copy/paste it to create the skeleton for Second section. Any tutorial which both uses a lot of AI and is supppsed to take an hour or so will probably only have two Sections.  -->

## Earthquakes
###

<!-- XX: Mention the packages/functions which you plan on covering in this Section. Not everything mentioned here is used in the Introduction/Summary, but everything in Introduction/Summary is referenced in one of these Section intro parts, the space before Exercise 1. -->

### Exercise 1

We begin by downloading our JSON file `data/earthquakes.geojson` directly from GitHub using `download.file()`. 

This adds the JSON file `earthquakes.geojson` to our working directory so we can use it in this tutorial.

In the Console, run:

```         
download.file(
  "https://github.com/PPBDS/ai.tutorials/raw/refs/heads/main/inst/tutorials/r4ds-5/data/earthquakes.geojson",
  destfile = "data/earthquakes.geojson"
)
```

CP/CR.

```{r earthquakes-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

### Exercise 2

Ask AI to help you read the JSON file `data/earthquakes.geojson` by using `jsonlite::read_json()` and then piping it into `str()` to explore its structure. Add this code to a new code chunk in the same QMD.

Place your cursor at the beginning of the line where it says `jsonlite...` and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r earthquakes-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r earthquakes-2-test, echo = TRUE}
jsonlite::read_json("data/earthquakes.geojson") |>
	str(max.levels = 2)
```

###

### Exercise 3

"Ask AI to use `jsonlite::read_json()` to read the `data/earthquakes.geojson` file, then use `pluck()` to extract the `features` list. Convert it into a tibble with `tibble(data = _)`. Use `unnest_wider()` to expand the `data` column, and then use `unnest_wider(properties, names_sep = "_")` to expand the `properties` list into separate columns such as `properties_mag`, `properties_place`, and `properties_time`. Add this code as a replacement to your current code in the same code chunk in the same QMD.

Place your cursor at the beginning of the line where it says `jsonlite...` and run `Cmd/Ctrl + Enter`.

CP/CR.


```{r earthquakes-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r earthquakes-3-test, echo = TRUE}
jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_")   
```

###

### Exercise 4

Ask AI to continue our pipe using `hoist()` to extract the coordinates directly from the geometry column without fully unnesting it.Add this code as a continuation of your current pipe in the same code chunk in the same QMD.

Place your cursor at the beginning of the line where it says `jsonlite...` and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r earthquakes-4}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r earthquakes-4-test, echo = TRUE}
jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_")   |>
  hoist(geometry, coordinates = "coordinates")
```

###

### Exercise 5

The coordinates column now contains lists with `longitude`,`latitude`, and `depth`. Ask AI to continue your pipe using `unnest_wider()` to separate these into individual columns, naming them appropriately using the `rename()` function. Add this code as a continuation of your current pipe in the same code chunk in the same QMD.

Place your cursor at the beginning of the line where it says `jsonlite...` and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r earthquakes-5}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r earthquakes-5-test, echo = TRUE}
jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_") |> 
  hoist(geometry, coordinates = "coordinates") |> 
  unnest_wider(coordinates, names_sep = "_") |> 
  rename(
    longitude = coordinates_1,
    latitude  = coordinates_2,
    depth     = coordinates_3
  )
```

###

### Exercise 6

Ask AI to use `across()` with `where()` to identify all character columns that might contain missing values coded as "null" strings, and convert them to actual NA values. Add this code as a continuation of your current pipe in the same code chunk in the same QMD.

Place your cursor at the beginning of the line where it says `jsonlite...` and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r earthquakes-6}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r earthquakes-6-test, echo = TRUE}
jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_") |> 
  hoist(geometry, coordinates = "coordinates") |> 
  unnest_wider(coordinates, names_sep = "_") |> 
  rename(
    longitude = coordinates_1,
    latitude  = coordinates_2,
    depth     = coordinates_3
  )|>
 mutate(across(where(is.character), ~ifelse(.x == "null", NA, .x)))
```

###

### Exercise 7

Ask AI to continue the pipe using `filter()` and `if_any()` to filter rows that have missing values in critical columns (`properties_mag`, `latitude`, `longitude`). Add this code as a continuation of your current pipe in the same code chunk in the same QMD.

Place your cursor at the beginning of the line where it says `jsonlite...` and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r earthquakes-7}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r earthquakes-7-test, echo = TRUE}
jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_") |> 
  hoist(geometry, coordinates = "coordinates") |> 
  unnest_wider(coordinates, names_sep = "_") |> 
  rename(
    longitude = coordinates_1,
    latitude  = coordinates_2,
    depth     = coordinates_3
  )|>
 mutate(across(where(is.character), ~ifelse(.x == "null", NA, .x))) |>
filter(!if_any(c(properties_mag, longitude, latitude), is.na))
```

###

### Exercise 8

You can write your own functions. We need to convert the time values from milliseconds since epoch to proper datetime. Ask AI to write a custom function called `convert_earthquake_time()` that converts milliseconds since Unix epoch to a datetime object using `as.POSIXct()`. Tell AI that the function should take a numeric vector of milliseconds and return a POSIXct datetime vector. Add this code to as a replacement to your current code in the same code chunk in the same QMD.

Place your cursor at the beginning of the line where it says `convert_eathquake_time...` and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r earthquakes-8}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 10)
```

###

Our code:

```{r, echo = TRUE}
 convert_earthquake_time <- function(milliseconds) {
   as.POSIXct(milliseconds / 1000, origin = "1970-01-01", tz = "UTC")
 }
```

###

Writing custom functions helps you encapsulate logic that you'll use repeatedly. The Unix epoch (January 1, 1970) is a common reference point for timestamps in data systems.

### Exercise 9

Ask AI to create another custom function called `categorize_magnitude()` that takes magnitude values and returns categories like "Minor" (< 3.0), "Light" (3.0-3.9), "Moderate" (4.0-4.9), "Strong" (5.0-5.9), "Major" (6.0-6.9), and "Great" (7.0+). Use your function to add a magnitude category column to the data. Add this code as a addition to your current code in the code chunk in the same QMD.

Place your cursor at the beginning of the line where it says `categorize_magnitude...` and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r earthquakes-9}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 10)
```

###

Our code:

```{r, echo = TRUE}
convert_earthquake_time <- function(milliseconds) {
   as.POSIXct(milliseconds / 1000, origin = "1970-01-01", tz = "UTC")
 }
categorize_magnitude <- function(mag) {
   case_when(
     mag < 3.0 ~ "Minor",
     mag < 4.0 ~ "Light", 
    mag < 5.0 ~ "Moderate",
     mag < 6.0 ~ "Strong",
     mag < 7.0 ~ "Major",
     TRUE ~ "Great"
   )
 }
```

###

### Exercise 10

Pipe from Exercise 7:

```
jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_") |> 
  hoist(geometry, coordinates = "coordinates") |> 
  unnest_wider(coordinates, names_sep = "_") |> 
  rename(
    longitude = coordinates_1,
    latitude  = coordinates_2,
    depth     = coordinates_3
  )|>
 	mutate(across(where(is.character), ~ifelse(.x == "null", NA, .x))) |>
 	filter(!if_any(c(properties_mag, longitude, latitude), is.na))
```

Paste our pipe from Exercise 7 into AI and ask AI to continue our pipe and apply our `convert_earthquake_time()` and `categorize_magnitude()` functions to create datetime and magnitude category columns. Make sure to use `as.numeric()`.  Add this code to a new code chunk in the same QMD.

Place your cursor at the beginning of the line where it says `jsonlite...` and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r earthquakes-10}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 15)
```

###

Our code:

```{r, echo = TRUE}
jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_") |> 
  hoist(geometry, coordinates = "coordinates") |> 
  unnest_wider(coordinates, names_sep = "_") |> 
  rename(
    longitude = coordinates_1,
    latitude  = coordinates_2,
    depth     = coordinates_3
  )|>
 	mutate(across(where(is.character), ~ifelse(.x == "null", NA, .x))) |>
 	filter(!if_any(c(properties_mag, longitude, latitude), is.na))|>
		mutate(
  			datetime = convert_earthquake_time(as.numeric(properties_time)),
  			mag_category = categorize_magnitude(as.numeric(properties_mag))
		)
```

###

### Exercise 11

Ask AI to continue your pipe using `across()` and convert magnitude and depth to numeric if they aren't already and then filter earthquakes from the last 7 days using `filter()` and `datetime >= Sys.Date() - 7`. Add this code as a continuation of your current pipe in the same code chunk in the same QMD.

Place your cursor at the beginning of the line where it says `jsonlite...` and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r earthquakes-11}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r earthquakes-11-test, echo = TRUE}
jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_") |> 
  hoist(geometry, coordinates = "coordinates") |> 
  unnest_wider(coordinates, names_sep = "_") |> 
  rename(
    longitude = coordinates_1,
    latitude  = coordinates_2,
    depth     = coordinates_3
  )|>
 	mutate(across(where(is.character), ~ifelse(.x == "null", NA, .x))) |>
 	filter(!if_any(c(properties_mag, longitude, latitude), is.na))|>
		mutate(
  			datetime = convert_earthquake_time(as.numeric(properties_time)),
  			mag_category = categorize_magnitude(as.numeric(properties_mag))
		)|>
mutate(across(c(properties_mag, depth), as.numeric)) |>
  filter(datetime >= Sys.Date() - 7) 
```

###

### Exercise 12

Ask AI to continue your pipe by using `filter()` function on `longitude` and `latitude` variables to restrict data to continental US bounds, then use `mutate()` to extract time features from `datetime` and categorize `depth` into shallow, intermediate, and deep groups. Add this code as a continuation of your current pipe in the same code chunk in the same QMD.

Place your cursor at the beginning of the line where it says `jsonlite...` and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r earthquakes-12}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r earthquakes-12-test, echo = TRUE}
jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_") |> 
  hoist(geometry, coordinates = "coordinates") |> 
  unnest_wider(coordinates, names_sep = "_") |> 
  rename(
    longitude = coordinates_1,
    latitude  = coordinates_2,
    depth     = coordinates_3
  )|>
 	mutate(across(where(is.character), ~ifelse(.x == "null", NA, .x))) |>
 	filter(!if_any(c(properties_mag, longitude, latitude), is.na))|>
		mutate(
  			datetime = convert_earthquake_time(as.numeric(properties_time)),
  			mag_category = categorize_magnitude(as.numeric(properties_mag))
		)|>
mutate(across(c(properties_mag, depth), as.numeric)) |>
  filter(datetime >= Sys.Date() - 7) |>
filter(longitude >= -125, longitude <= -66, latitude >= 20, latitude <= 50) |>
mutate(
  hour = hour(datetime),
  day_of_week = wday(datetime, label = TRUE),
  depth_category = case_when(
    depth < 70 ~ "Shallow",
    depth < 300 ~ "Intermediate",
    depth < 600 ~ "Deep"
  )
)
```

###

### Exercise 13

Ask AI to continue your pipe by using the `select()` function on `longitude, latitude, properties_mag, properties_place, datetime, depth, mag_category, depth_category`, then use `mutate()` to create a `tooltip_text` column that combines `magnitude, location, time, and depth` information into HTML-formatted text. Add this code as a continuation of your current pipe in the same code chunk in the same QMD.

Place your cursor at the beginning of the line where it says `jsonlite...` and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r earthquakes-13}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r earthquakes-13-test, echo = TRUE}
jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_") |> 
  hoist(geometry, coordinates = "coordinates") |> 
  unnest_wider(coordinates, names_sep = "_") |> 
  rename(
    longitude = coordinates_1,
    latitude  = coordinates_2,
    depth     = coordinates_3
  )|>
 	mutate(across(where(is.character), ~ifelse(.x == "null", NA, .x))) |>
 	filter(!if_any(c(properties_mag, longitude, latitude), is.na))|>
		mutate(
  			datetime = convert_earthquake_time(as.numeric(properties_time)),
  			mag_category = categorize_magnitude(as.numeric(properties_mag))
		)|>
mutate(across(c(properties_mag, depth), as.numeric)) |>
  filter(datetime >= Sys.Date() - 7) |>
filter(longitude >= -125, longitude <= -66, latitude >= 20, latitude <= 50) |>
mutate(
  hour = hour(datetime),
  day_of_week = wday(datetime, label = TRUE),
  depth_category = case_when(
    depth < 70 ~ "Shallow",
    depth < 300 ~ "Intermediate",
    depth < 600 ~ "Deep"
  )
) |>
	select(longitude, latitude, properties_mag, properties_place, datetime, depth, mag_category, depth_category) |>
mutate(
  tooltip_text = paste0(
    "Magnitude: ", properties_mag, " (", mag_category, ")<br>",
    "Location: ", properties_place, "<br>",
    "Time: ", format(datetime, "%Y-%m-%d %H:%M"), "<br>",
    "Depth: ", round(depth, 1), " km (", depth_category, ")"
  )
)
```

###

### Exercise 14

Ask AI to continue your pipe by using `filter()`  on `longitude`,` latitude`, and `properties_mag`  to ensure all values are within valid geographic bounds. Add this code as a continuation of your current pipe in the same code chunk in the same QMD.

Place your cursor at the beginning of the line where it says `jsonlite...` and run `Cmd/Ctrl + Enter`.

CP/CR.

```{r earthquakes-14}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r earthquakes-14-test, echo = TRUE}
jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_") |> 
  hoist(geometry, coordinates = "coordinates") |> 
  unnest_wider(coordinates, names_sep = "_") |> 
  rename(
    longitude = coordinates_1,
    latitude  = coordinates_2,
    depth     = coordinates_3
  )|>
 	mutate(across(where(is.character), ~ifelse(.x == "null", NA, .x))) |>
 	filter(!if_any(c(properties_mag, longitude, latitude), is.na))|>
		mutate(
  			datetime = convert_earthquake_time(as.numeric(properties_time)),
  			mag_category = categorize_magnitude(as.numeric(properties_mag))
		)|>
mutate(across(c(properties_mag, depth), as.numeric)) |>
  filter(datetime >= Sys.Date() - 7) |>
filter(longitude >= -125, longitude <= -66, latitude >= 20, latitude <= 50) |>
mutate(
  hour = hour(datetime),
  day_of_week = wday(datetime, label = TRUE),
  depth_category = case_when(
    depth < 70 ~ "Shallow",
    depth < 300 ~ "Intermediate",
    depth < 600 ~ "Deep"
  )
) |>
	select(longitude, latitude, properties_mag, properties_place, datetime, depth, mag_category, depth_category) |>
	mutate(
		tooltip_text = paste0(
		"Magnitude: ", properties_mag, " (", mag_category, ")<br>",
		"Location: ", properties_place, "<br>",
		"Time: ", format(datetime, "%Y-%m-%d %H:%M"), "<br>",
		"Depth: ", round(depth, 1), " km (", depth_category, ")"
	)
	)|>
	filter(
  		longitude >= -180, longitude <= 180,
  		latitude >= -90, latitude <= 90,
  		properties_mag >= 0, properties_mag <= 10
	)
```

###

### Exercise 15

Ask AI to continue your pipe by using `mutate()` on `properties_mag`  to create a color column that assigns colors based on earthquake magnitude severity, then use `arrange()` to sort by magnitude in descending order.

```{r earthquakes-15}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 5)
```

###

Our code:

```{r earthquakes-15-test, echo = TRUE}
jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_") |> 
  hoist(geometry, coordinates = "coordinates") |> 
  unnest_wider(coordinates, names_sep = "_") |> 
  rename(
    longitude = coordinates_1,
    latitude  = coordinates_2,
    depth     = coordinates_3
  )|>
 	mutate(across(where(is.character), ~ifelse(.x == "null", NA, .x))) |>
 	filter(!if_any(c(properties_mag, longitude, latitude), is.na))|>
		mutate(
  			datetime = convert_earthquake_time(as.numeric(properties_time)),
  			mag_category = categorize_magnitude(as.numeric(properties_mag))
		)|>
mutate(across(c(properties_mag, depth), as.numeric)) |>
  filter(datetime >= Sys.Date() - 7) |>
filter(longitude >= -125, longitude <= -66, latitude >= 20, latitude <= 50) |>
mutate(
  hour = hour(datetime),
  day_of_week = wday(datetime, label = TRUE),
  depth_category = case_when(
    depth < 70 ~ "Shallow",
    depth < 300 ~ "Intermediate",
    depth < 600 ~ "Deep"
  )
) |>
	select(longitude, latitude, properties_mag, properties_place, datetime, depth, mag_category, depth_category) |>
	mutate(
		tooltip_text = paste0(
		"Magnitude: ", properties_mag, " (", mag_category, ")<br>",
		"Location: ", properties_place, "<br>",
		"Time: ", format(datetime, "%Y-%m-%d %H:%M"), "<br>",
		"Depth: ", round(depth, 1), " km (", depth_category, ")"
	)
	)|>
	filter(
  		longitude >= -180, longitude <= 180,
  		latitude >= -90, latitude <= 90,
  		properties_mag >= 0, properties_mag <= 10
	) |>
mutate(
  color = case_when(
    properties_mag >= 6 ~ "red",
    properties_mag >= 5 ~ "orange",
    properties_mag >= 4 ~ "yellow",
    properties_mag >= 3 ~ "green",
    TRUE ~ "blue"
  )
) |>
arrange(desc(properties_mag))
```

###

### Exercise 16

Before creating a plot, we need to ensure that your data matches our data. In the QMD, replace your code from the previous exercise with our code.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r earthquakes-16}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 6)
```

###

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 17

Within the latest code chunk, add the option: `#| cache: true`. Assign the result of the pipe to `earthquake_df`. 

`Cmd/Ctrl + Shift + K`. By including `#| cache: true` you cause Quarto to cache the results of the chunk. The next time you render your QMD, as long as you have not changed the code, Quarto will just load up the saved object.

If you have not done so already, you should add `analysis_cache` to the `.gitginore`. The content of the cache file does not belong on GitHub.

Place your cursor on the line where the pipe is assigned to `earthquake_df`, run `Cmd/Ctrl + Enter`, thus ensuring that the workspace also includes a copy of `earthquake_df`.

CP/CR.

```{r earthquakes-17}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 8)
```

###

Our code:

```{r, echo = TRUE}
earthquake_df <- jsonlite::read_json("data/earthquakes.geojson") |>
  pluck("features") |> 
  tibble(data = _) |> 
  unnest_wider(data) |> 
  unnest_wider(properties, names_sep = "_") |> 
  hoist(geometry, coordinates = "coordinates") |> 
  unnest_wider(coordinates, names_sep = "_") |> 
  rename(
    longitude = coordinates_1,
    latitude  = coordinates_2,
    depth     = coordinates_3
  )|>
 	mutate(across(where(is.character), ~ifelse(.x == "null", NA, .x))) |>
 	filter(!if_any(c(properties_mag, longitude, latitude), is.na))|>
		mutate(
  			datetime = convert_earthquake_time(as.numeric(properties_time)),
  			mag_category = categorize_magnitude(as.numeric(properties_mag))
		)|>
mutate(across(c(properties_mag, depth), as.numeric)) |>
  filter(datetime >= Sys.Date() - 7) |>
  filter(longitude >= -125, longitude <= -66, latitude >= 20, latitude <= 50) |>
  mutate(
    hour = hour(datetime),
    day_of_week = wday(datetime, label = TRUE),
    depth_category = case_when(
      depth < 70 ~ "Shallow",
      depth < 300 ~ "Intermediate", 
      depth < 600 ~ "Deep"
    )
  )|>
  select(longitude, latitude, properties_mag, properties_place, datetime, depth, mag_category, depth_category) |>
  mutate(
    tooltip_text = paste0(
      "Magnitude: ", properties_mag, " (", mag_category, ")<br>",
      "Location: ", properties_place, "<br>",
      "Time: ", format(datetime, "%Y-%m-%d %H:%M"), "<br>",
      "Depth: ", round(depth, 1), " km (", depth_category, ")"
    )
  )|>
  filter(
    longitude >= -180, longitude <= 180,
    latitude >= -90, latitude <= 90,
    properties_mag >= 0, properties_mag <= 10
  ) |>
  mutate(
    color = case_when(
      properties_mag >= 6 ~ "red",
      properties_mag >= 5 ~ "orange", 
      properties_mag >= 4 ~ "yellow",
      properties_mag >= 3 ~ "green",
      TRUE ~ "blue"
    )
  ) |>
  arrange(desc(properties_mag))
```

###

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 18

Within the Console, type `earthquake_df`, which we previously assigned to a pipe and ran in the Console. Hit `Enter`.

CP/CR.

```{r earthquakes-18}
question_text(NULL,
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL,
    rows = 8)
```

###


Our code:

```{r, echo=TRUE}
earthquake_df
```

###

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 19

Ask AI to generate R code that uses the `earthquake_df` tibble to create an interactive map showing earthquakes in the U.S. Mention that you want to use the data from `earthquake_df` and include the top 3 rows (mainly to show column names). The map should use `leaflet()` with `addTiles()` and `addCircleMarkers()` to plot points with `longitude` and `latitude`, sized by `properties_mag`, colored by `color`, and showing `tooltip_text` on popups. Also, add a legend with `addLegend()` to label earthquake magnitudes with colors and categories.

Within `labs()`, edit or add a proper title, subtitle, and caption. If axis labels would be useful, add them, but if unnecessary, don't bother. Don't assign the code for the plot to any variable. Put the plot code in a new code chunk. Run `Cmd/Ctrl + Shift + K` to ensure that everything works. Make your plot look nice.

In the Console, run:

```         
show_file("analysis.qmd", chunk = "Last")
```

CP/CR.

```{r earthquakes-19}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 12)
```

###

Our code:

```{r, echo=TRUE}
leaflet(earthquake_df) |>
  addTiles() |>
  addCircleMarkers(
    lng = ~longitude,
    lat = ~latitude,
    radius = ~properties_mag * 2,
    color = ~color,
    popup = ~tooltip_text,
    fillOpacity = 0.7,
    stroke = TRUE,
    weight = 1
  ) |>
  addLegend(
    position = "bottomright",
    colors = c("red", "orange", "yellow", "green", "blue"),
    labels = c("Major (6.0+)", "Strong (5.0-5.9)", "Moderate (4.0-4.9)", 
              "Light (3.0-3.9)", "Minor (<3.0)"),
    title = "Earthquake Magnitude"
  )
```

###

<!-- XX: Make sure your plotting code is good! This will take some time. You had better have a subtitle which provides the take-away message of the plot. AI sometimes gives you too much code, lots of `theme()` stuff and so on. This is no good! In most cases, we are happy with concise, straightforward code. Insert a knowledge drop related to this project. -->

## Summary
###

<!-- XX: The exact same two to four sentence about the main packages/functions used in the Introduction, but written here in the past tense. You made a promise and you kept it.  -->

### Exercise 1

`Cmd/Ctrl + Shift + K` to ensure that everything works.  The resulting HTML page should be attractive, showing clean versions of your plots.

At the Console, run:

```
tutorial.helpers::show_file("analysis.qmd")
```

CP/CR.

```{r summary-1}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 30)
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 2

Publish your rendered QMD to GitHub Pages. In the Terminal --- not the Console! --- run:

````
quarto publish gh-pages analysis.qmd
````

Copy/paste the resulting URL below.

```{r summary-2}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 1)
```

### 

<!-- XX: Insert a knowledge drop related to this project. -->

### Exercise 3

Commit and push all your files. Copy/paste the URL to your Github repo.

```{r summary-3}
question_text(NULL,
	answer(NULL, correct = TRUE),
	allow_retry = TRUE,
	try_again_button = "Edit Answer",
	incorrect = NULL,
	rows = 3)
```

### 

<!-- XX: The tutorial is now over. Add any necessary acknowledgements and/or provide a link to further high quality readings, ideally readings which you mentioned in at least one knowledge drop above. -->

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
